{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"miller","text":"Version Status Docs Compatibility Stats Tools"},{"location":"#what-is-miller","title":"What is miller?","text":"<p>\"I'm a tool that finds things.\" - Detective Josephus Miller</p> <p> </p> <p>Named after the erstwhile inspector from The Expanse, this package provides convenient, introspection tools using a consistent, intuitive syntax for packages, modules, classes, objects, attributes, and containers. </p>"},{"location":"#why-use-miller","title":"Why use miller?","text":""},{"location":"#universal","title":"Universal","text":"<p>Consider the different and often difficult-to-read syntax that Python uses for introspection of different objects. <pre><code>\"\"\"Returns a list of function names in the module 'item'.\"\"\"\n[m[0] for m in inspect.getmembers(item, inspect.isfunction) \n if m[1].__module__ == item.__name__]\n\n\"\"\"Returns names of properties of the instance 'item'.\"\"\"\n[a for a in dir(item) if isinstance(getattr(a, item), property)] \n\n\"\"\"Returns names of fields of the dataclass 'item'.\"\"\"\n[f.name for f in dataclasses.fields(item)] \n</code></pre> That code can be difficult to remember, requires importing a range of packages, and is not easy to understand if you are not familiar with the relevant imported packages. </p> <p> </p> <p>In contrast, miller uses simple, easy-to-read code for each of the above requests:</p> <p><pre><code>name_functions(item)\nname_properties(item)\nname_fields(item)\n</code></pre> In addition, each of those miller functions includes a boolean parameter <code>include_privates</code> which indicates whether you want to include any matching items that have str names beginning with an underscore.</p>"},{"location":"#intuitive","title":"Intuitive","text":"<p>Unlike the default Python instrospection functions and methods, miller uses a consistent syntax and structure that is far more intuitive. This allows users to guess what the appropriate syntax should by following a simple, consistent structure.</p> <p>miller uses five basic prefixes for its introspection functions:</p> prefix what it does returns <code>map</code> combines results of corresponding  <code>name</code> and <code>get</code> functions into a <code>dict</code> <code>dict[str, Any]</code> <code>get</code> gets sought types from an item <code>list[Any]</code> <code>has</code> whether an item has specified types <code>bool</code> <code>is</code> whether an item is a type <code>bool</code> <code>name</code> gets <code>str</code> names of sought types from an item <code>list[str]</code> <p>Those prefixes are followed by an underscore and a suffix indicating what information is sought. miller has XXX possible suffixes for each of those prefixes: | suffix  | what it concerns   | what types it inspects   | |---|---|---| | <code>annotations</code>  | class, function, or method annotations   | <code>object</code>, <code>Type</code>, or <code>ModuleType</code>  | | <code>attribute</code>  | an attribute (including methods) of a class  | attribute in an <code>object</code> or <code>Type</code> | | <code>attributes</code>  | attributes (including methods or functions)  |  <code>object</code>, <code>Type</code>, or <code>ModuleType</code>  | | <code>class</code>  | a class (not an instance)  | <code>object</code> or <code>Type</code> | | <code>classes</code>  | classes in a module    | <code>ModuleType</code>   | | <code>class_attribute</code>  | attributes of a class (not an instance)  | <code>object</code> or <code>Type</code> | | <code>class_attributes</code>  | attributes of a class (not an instance)    | <code>object</code> or <code>Type</code>    | | <code>field</code>  | field in a dataclass  | <code>dataclass</code> or <code>Type[dataclass]</code> | | <code>fields</code>  | fields in a dataclass  | <code>dataclass</code> or <code>Type[dataclass]</code>  | | <code>file_path</code>  | path of a file | <code>str</code> or <code>Path</code>  | | <code>file_paths</code>  | paths of files in a path  | <code>str</code> or <code>Path</code>  | | <code>folder_path</code>  | path of a folder  | <code>str</code> or <code>Path</code>  | | <code>folder_paths</code>  | paths of folders in a path   | <code>str</code> or <code>Path</code>  | | <code>function</code>  | a callable function  | <code>object</code>| | <code>functions</code>  | functions in a module  | <code>ModuleType</code>  | | <code>instance</code>  | a class instance (not a class)  | <code>object</code> or <code>Type</code> | | <code>method</code>  | method in a class  | attribute in an <code>object</code> or <code>Type</code> | | <code>methods</code>  | class or instance methods  | <code>object</code> or <code>Type</code>   | | <code>module</code>  | module types  | <code>object</code> or <code>Type</code> | | <code>modules</code>  | paths of modules in a path   |  <code>str</code> or <code>Path</code>  | | <code>path</code>  | path on disk  | <code>str</code> or <code>Path</code> | | <code>paths</code>  | combination of file_paths and folder_paths  | <code>str</code> or <code>Path</code>   | | <code>property</code>  | attributes of a class  | attribute in an <code>object</code> | | <code>properties</code>  | properties of a class  | <code>object</code> or <code>Type</code>   | | <code>signatures</code>  | class, function, or method signatures  | <code>object</code>, <code>Type</code>, or <code>ModuleType</code>    | | <code>variable</code>  | attributes (excluding methods) of a class | <code>object</code>, <code>Type</code>, or <code>ModuleType</code>   | | <code>variables</code>  | an attribute (excluding methods or functions)  |  <code>object</code>, <code>Type</code>, or <code>ModuleType</code>   |</p> <p>The following functions are available in miller for the <code>map</code>, <code>get</code>, <code>has</code>, and <code>name</code>  suffixes :</p> <p>| prefix/suffix | <code>map</code>  | <code>get</code>  | <code>has</code>  | <code>name</code>  | |---|---|---|---|---|---|---| | <code>annotations</code> | X | X | X | X | | <code>attributes</code> | X | X | X | X |  | <code>classes</code> | X | X | X | X |  | <code>fields</code> | X | X | X | X |  | <code>file_paths</code> | X | X | X | X |  | <code>folder_paths</code> | X | X | X | X |  | <code>functions</code> | X | X | X | X |  | <code>methods</code> | X | X | X | X |  | <code>modules</code> | X | X | X | X | | <code>paths</code>  | X | X | X | X |  | <code>properties</code> | X | X | X | X |  | <code>signatures</code> | X | X | X | X |  | <code>variables</code> | X | X | X | X | </p> <p>For the <code>is</code> prefix, functions with the following suffixes are included: </p> <p>So, for example, </p> <ul> <li><code>map_methods</code>: returns a dict of the method names and methods of an object.</li> <li><code>list_methods</code>: returns a list of methods of an object.</li> <li><code>has_methods</code>: returns whether an object has all of the named methods passed to the <code>methods</code> parameter.</li> <li><code>is_method</code>: returns whether an item is a method of an object.</li> <li><code>name_methods</code>: returns a list of names of methods of an object.</li> </ul> <p> </p>"},{"location":"#getting-started","title":"Getting started","text":""},{"location":"#requirements","title":"Requirements","text":"<p>[TODO: List any OS or other restrictions and pre-installation dependencies]</p>"},{"location":"#installation","title":"Installation","text":"<p>[TODO: Briefly describe, with code blocks, how to install the project]</p>"},{"location":"#usage","title":"Usage","text":"<p>[TODO: Describe common use cases, with possible example(s)]</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributors are always welcome. Feel free to grab an issue to work on or make a suggested improvement. If you wish to contribute, please read the Contribution Guide and Code of Conduct.</p>"},{"location":"#similar-projects","title":"Similar Projects","text":"<p>[TODO: If they exist, it is always nice to acknowledge other similar efforts]</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>[TODO: Mention any people or organizations that warrant a special acknowledgment]</p>"},{"location":"#license","title":"License","text":"<p>Use of this repository is authorized under the Apache Software License 2.0.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file. Changes before 0.1.10 were lost in the transition away from poetry.</p> <p>0.1.10     Switched to snickerdoodle template </p>"},{"location":"code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to make participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or   advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic   address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"code_of_conduct/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all project spaces, and it also applies when an individual is representing the project or its community in public spaces. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting any of the following people:</p> <ul> <li>Corey Rayburn Yung (coreyrayburnyung@gmail.com)</li> </ul> <p>All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p> <p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html</p> <p>For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome and greatly appreciated! Every little bit helps, and credit will always be given. Environment Setup</p>"},{"location":"contributing/#development","title":"Development","text":"<p>Follow this basic process:</p> <ol> <li>Fork and clone the repositor.</li> <li>Create a new branch: <code>git checkout -b feature-or-bugfix-name</code>.</li> <li>Edit the code.</li> <li>If you added functionality or features, update the documentation accordingly.</li> </ol> <p>If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review.</p> <p>Don't bother updating the changelog, we will take care of this.</p>"},{"location":"contributing/#pull-requests-guidelines","title":"Pull requests guidelines","text":"<p>Link to any related issue in the Pull Request message.</p> <p>During the review, we recommend using fixups:</p> <pre><code># SHA is the SHA of the commit you want to fix\ngit commit --fixup=SHA\n</code></pre> <p>Once all the changes are approved, you can squash your commits:</p> <pre><code>git rebase -i --autosquash main\n</code></pre> <p>And force-push:</p> <pre><code>git push -f\n</code></pre> <p>If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.</p>"},{"location":"contributing/#style-guidelines","title":"Style Guidelines","text":"<p>This package follows the Google Python Style Guide with two notable exceptions:</p> <ol> <li>It always adds spaces around \"=\". This not only violates the Google guide, it violates PEP8, the foundational Python style guide from which all other resources are derived. I defy this strong, long-standign norm because I find it more readable. My brain and eyes have trouble seeing two separate objects when an equal sign is in the middle. I imagine that I am not alone in this accessibility issue. Further, as PEP8 itself notes, required spaces around equal signs are becoming increasing common with type annotations becoming part of best practices (and, as a result, signatures to classes, functions, and methods regularly include spaces around the equal signs). I realize that this will seem alien to many coders, but it is far easier on my eyes.</li> <li>I use some so-called \"power features\", primarily dunder methods, to make my interfaces easier to access and use. This is disfavored in the Google Python Style Guide because such code is often more difficult for others to read. To address that concern, I try to document and comment as to what the code is doing whenever I used any of the \"power features\" of Python.</li> </ol>"},{"location":"credits/","title":"Credits","text":"<p><p>These projects were used to build miller. Thank you!</p> <p><code>python</code> | <code>pdm</code></p> </p>"},{"location":"credits/#exec-1--runtime-dependencies","title":"Runtime dependencies","text":"Project Summary Version (accepted) Version (last resolved) License <code>camina</code> Your Python project companion <code>&gt;= 0.1.16</code> <code>0.1.16</code> Apache-2.0 <code>nagata</code> python file management using a common, intuitive syntax <code>&gt;= 0.1.6</code> <code>0.1.6</code> Apache-2.0"},{"location":"credits/#exec-1--development-dependencies","title":"Development dependencies","text":"Project Summary Version (accepted) Version (last resolved) License <code>babel</code> Internationalization utilities <code>&gt;=2.10.3</code> <code>2.12.1</code> BSD <code>beautifulsoup4</code> Screen-scraping library <code>4.12.2</code> MIT License <code>certifi</code> Python package for providing Mozilla's CA Bundle. <code>&gt;=2017.4.17</code> <code>2023.7.22</code> MPL-2.0 <code>cfgv</code> Validate configuration and produce human readable error messages. <code>&gt;=2.0.0</code> <code>3.4.0</code> MIT <code>charset-normalizer</code> The Real First Universal Charset Detector. Open, modern and actively maintained alternative to Chardet. <code>&lt;4,&gt;=2</code> <code>3.2.0</code> MIT <code>click</code> Composable command line interface toolkit <code>&gt;=7.0</code> <code>8.1.7</code> BSD-3-Clause <code>colorama</code> Cross-platform colored terminal text. <code>&gt;=0.4; platform_system == \"Windows\"</code> <code>0.4.6</code> BSD License <code>coverage</code> Code coverage measurement for Python <code>&gt;= 7.2.7</code> <code>7.3.0</code> Apache-2.0 <code>csscompressor</code> A python port of YUI CSS Compressor <code>&gt;=0.9.5</code> <code>0.9.5</code> BSD <code>cssselect</code> cssselect parses CSS3 Selectors and translates them to XPath 1.0 <code>&gt;=1.2.0</code> <code>1.2.0</code> BSD <code>distlib</code> Distribution utilities <code>&lt;1,&gt;=0.3.7</code> <code>0.3.7</code> PSF-2.0 <code>exceptiongroup</code> Backport of PEP 654 (exception groups) <code>&gt;=1.0.0rc8; python_version &lt; \"3.11\"</code> <code>1.1.3</code> ? <code>execnet</code> execnet: rapid multi-Python deployment <code>&gt;=1.1</code> <code>2.0.2</code> MIT License <code>filelock</code> A platform independent file lock. <code>&lt;4,&gt;=3.12.2</code> <code>3.12.3</code> The Unlicense (Unlicense) <code>ghp-import</code> Copy your docs directly to the gh-pages branch. <code>&gt;=1.0</code> <code>2.1.0</code> Apache Software License <code>gitdb</code> Git Object Database <code>&lt;5,&gt;=4.0.1</code> <code>4.0.10</code> BSD License <code>gitpython</code> GitPython is a Python library used to interact with Git repositories <code>3.1.32</code> BSD <code>griffe</code> Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API. <code>&gt;=0.35</code> <code>0.35.2</code> ISC <code>htmlmin2</code> An HTML Minifier <code>&gt;=0.1.13</code> <code>0.1.13</code> BSD <code>identify</code> File identification library for Python <code>&gt;=1.0.0</code> <code>2.5.27</code> MIT <code>idna</code> Internationalized Domain Names in Applications (IDNA) <code>&lt;4,&gt;=2.5</code> <code>3.4</code> BSD License <code>iniconfig</code> brain-dead simple config-ini parsing <code>2.0.0</code> MIT License <code>jinja2</code> A very fast and expressive template engine. <code>&gt;=2.11.1</code> <code>3.1.2</code> BSD-3-Clause <code>jsmin</code> JavaScript minifier. <code>&gt;=3.0.1</code> <code>3.0.1</code> MIT License <code>lxml</code> Powerful and Pythonic XML processing library combining libxml2/libxslt with the ElementTree API. <code>&gt;=4.6</code> <code>4.9.3</code> BSD-3-Clause <code>markdown</code> Python implementation of John Gruber's Markdown. <code>&lt;4.0.0,&gt;=3.3.3</code> <code>3.4.4</code> BSD License <code>markdown-callouts</code> Markdown extension: a classier syntax for admonitions <code>&gt;= 0.3</code> <code>0.3.0</code> MIT <code>markdown-exec</code> Utilities to execute code blocks in Markdown files. <code>&gt;= 1.6.0</code> <code>1.6.0</code> ISC <code>markdown2</code> A fast and complete Python implementation of Markdown <code>&gt;=2.4.3</code> <code>2.4.10</code> MIT <code>markupsafe</code> Safely add untrusted strings to HTML/XML markup. <code>&gt;=2.0.1</code> <code>2.1.3</code> BSD-3-Clause <code>mergedeep</code> A deep merge function for \ud83d\udc0d. <code>&gt;=1.3.4</code> <code>1.3.4</code> MIT License <code>mkdocs</code> Project documentation with Markdown. <code>&gt;= 1.5.2</code> <code>1.5.2</code> BSD License <code>mkdocs-coverage</code> MkDocs plugin to integrate your coverage HTML report into your site. <code>&gt;= 1.0.0</code> <code>1.0.0</code> ISC <code>mkdocs-gen-files</code> MkDocs plugin to programmatically generate documentation pages during the build <code>&gt;= 0.5.0</code> <code>0.5.0</code> MIT License <code>mkdocs-git-committers-plugin-2</code> An MkDocs plugin to create a list of contributors on the page <code>&gt;= 1.1.2</code> <code>1.1.2</code> MIT <code>mkdocs-literate-nav</code> MkDocs plugin to specify the navigation in Markdown instead of YAML <code>&gt;= 0.6.0</code> <code>0.6.0</code> MIT License <code>mkdocs-material</code> Documentation that simply works <code>&gt;= 9.1.2</code> <code>9.2.5</code> MIT License <code>mkdocs-material-extensions</code> Extension pack for Python Markdown and MkDocs Material. <code>&gt;=1.1</code> <code>1.1.1</code> MIT License <code>mkdocs-minify-plugin</code> An MkDocs plugin to minify HTML, JS or CSS files prior to being written to disk <code>&gt;= 0.7.1</code> <code>0.7.1</code> MIT <code>mkdocstrings</code> Automatic documentation from sources, for MkDocs. <code>[python] &gt;= 0.22.0</code> <code>0.22.0</code> ISC <code>mkdocstrings-python</code> A Python handler for mkdocstrings. <code>&gt;=0.5.2</code> <code>1.6.0</code> ISC <code>nodeenv</code> Node.js virtual environment builder <code>&gt;=0.11.1</code> <code>1.8.0</code> BSD <code>packaging</code> Core utilities for Python packages <code>&gt;=20.5</code> <code>23.1</code> BSD License <code>paginate</code> Divides large result sets into pages for easier browsing <code>&gt;=0.5.6</code> <code>0.5.6</code> MIT <code>pathspec</code> Utility library for gitignore style pattern matching of file paths. <code>&gt;=0.11.1</code> <code>0.11.2</code> Mozilla Public License 2.0 (MPL 2.0) <code>platformdirs</code> A small Python package for determining appropriate platform-specific dirs, e.g. a \"user data dir\". <code>&gt;=2.2.0</code> <code>3.10.0</code> MIT License <code>pluggy</code> plugin and hook calling mechanisms for python <code>&lt;2.0,&gt;=0.12</code> <code>1.3.0</code> MIT <code>pre-commit</code> A framework for managing and maintaining multi-language pre-commit hooks. <code>&gt;= 3.3.3</code> <code>3.3.3</code> MIT <code>pygments</code> Pygments is a syntax highlighting package written in Python. <code>&gt;=2.14</code> <code>2.16.1</code> BSD-2-Clause <code>pymdown-extensions</code> Extension pack for Python Markdown. <code>&gt;=9</code> <code>10.2.1</code> MIT License <code>pyquery</code> A jquery-like library for python <code>&gt;=1.2</code> <code>2.0.0</code> BSD <code>pytest</code> pytest: simple powerful testing with Python <code>&gt;= 7.4.0</code> <code>7.4.0</code> MIT <code>pytest-cov</code> Pytest plugin for measuring coverage. <code>&gt;= 4.1.0</code> <code>4.1.0</code> MIT <code>pytest-randomly</code> Pytest plugin to randomly order tests and control random.seed. <code>&gt;= 3.13.0</code> <code>3.15.0</code> MIT <code>pytest-xdist</code> pytest xdist plugin for distributed testing, most importantly across multiple CPUs <code>&gt;= 3.3.1</code> <code>3.3.1</code> MIT <code>python-dateutil</code> Extensions to the standard Python datetime module <code>&gt;=2.8.1</code> <code>2.8.2</code> Dual License <code>pyyaml</code> YAML parser and emitter for Python <code>&gt;=5.1</code> <code>6.0.1</code> MIT <code>pyyaml-env-tag</code> A custom YAML tag for referencing environment variables in YAML files. <code>&gt;=0.1</code> <code>0.1</code> MIT License <code>readtime</code> Calculates the time some text takes the average human to read, based on Medium's read time forumula <code>&gt;=2.0</code> <code>3.0.0</code> BSD <code>regex</code> Alternative regular expression module, to replace re. <code>&gt;=2022.4.24</code> <code>2023.8.8</code> Apache Software License <code>requests</code> Python HTTP for Humans. <code>2.31.0</code> Apache 2.0 <code>ruff</code> An extremely fast Python linter, written in Rust. <code>&gt;= 0.0.286</code> <code>0.0.286</code> MIT <code>setuptools</code> Easily download, build, install, upgrade, and uninstall Python packages <code>68.1.2</code> MIT License <code>six</code> Python 2 and 3 compatibility utilities <code>&gt;=1.5</code> <code>1.16.0</code> MIT <code>smmap</code> A pure Python implementation of a sliding window memory map manager <code>&lt;6,&gt;=3.0.1</code> <code>5.0.0</code> BSD <code>soupsieve</code> A modern CSS selector implementation for Beautiful Soup. <code>&gt;1.2</code> <code>2.4.1</code> MIT License <code>toml</code> Python Library for Tom's Obvious, Minimal Language <code>&gt;= 0.10.2</code> <code>0.10.2</code> MIT <code>tomli</code> A lil' TOML parser <code>; python_full_version &lt;= \"3.11.0a6\"</code> <code>2.0.1</code> ? <code>typing-extensions</code> Backported and Experimental Type Hints for Python 3.7+ <code>&gt;=4.7.1; python_version &lt; \"3.11\"</code> <code>4.7.1</code> ? <code>urllib3</code> HTTP library with thread-safe connection pooling, file post, and more. <code>&lt;3,&gt;=1.21.1</code> <code>2.0.4</code> MIT License <code>virtualenv</code> Virtual Python Environment builder <code>&gt;=20.10.0</code> <code>20.24.4</code> MIT License <code>watchdog</code> Filesystem events monitoring <code>&gt;=2.0</code> <code>3.0.0</code> Apache License 2.0"},{"location":"license/","title":"License","text":"<p>Apache Software License 2.0</p> <p>Copyright \u00a9 2023, Corey Rayburn Yung</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p> <p>http://www.apache.org/licenses/LICENSE-2.0</p> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li> miller<ul> <li> attributes</li> <li> base</li> <li> configuration</li> <li> containers</li> <li> disks</li> <li> examiners</li> <li> framework</li> <li> identity</li> <li> modules</li> </ul> </li> </ul>"},{"location":"reference/miller/","title":"Index","text":"<p>Introspection tools using a consistent and intuitive syntax.</p>"},{"location":"reference/miller/attributes/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> attributes","text":"<p>attributes: introspection tools for class and instance attributes Corey Rayburn Yung coreyrayburnyung@gmail.com Copyright 2020-2022, Corey Rayburn Yung License: Apache-2.0</p> <pre><code>Licensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre> Contents <p>This module contains the following types of inspectors:     has     is     list     map     name Those relate to the following attributes of classes and instances:     attributes     fields     methods     properties     traits</p> ToDo <p>Add functions for annotation instrospection.</p>"},{"location":"reference/miller/attributes/#miller.attributes.has_attributes","title":"<code>has_attributes(item, attributes, raise_error=None, match_all=None)</code>","text":"<p>Returns whether 'attributes' exist in 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>class or instance to examine.</p> required <code>attributes</code> <code>MutableSequence[str]</code> <p>names of attributes to check.</p> required <code>raise_error</code> <code>Optional[bool]</code> <p>whether to raise an error if any  'attributes' are not attributes of 'item' (True) or to simply  return False in such situations. Defaults to None, which means the  global 'miller.RAISE_ERRORS' setting will be used.</p> <code>None</code> <code>match_all</code> <code>Optional[bool]</code> <p>whether all items in 'attributes' must match (True) or any of the items must match (False). Defaults to None, which means the global 'miller.MATCH_ALL' will be used.</p> <code>None</code> <p>Raises:</p> Type Description <code>AttributeError</code> <p>if 'attributes' are not attributes of 'item' and  'raise_error' is True (or if it is None and the global setting is True).</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether some or all (depending on 'match_all') of 'attributes'  exist in 'item'.</p> Source code in <code>src/miller/attributes.py</code> <pre><code>def has_attributes(\n    item: Any, \n    attributes: MutableSequence[str], \n    raise_error: Optional[bool] = None,\n    match_all: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns whether 'attributes' exist in 'item'.\n\n    Args:\n        item (Any): class or instance to examine.\n        attributes (MutableSequence[str]): names of attributes to check.\n        raise_error (Optional[bool]): whether to raise an error if any \n            'attributes' are not attributes of 'item' (True) or to simply \n            return False in such situations. Defaults to None, which means the \n            global 'miller.RAISE_ERRORS' setting will be used.\n        match_all (Optional[bool]): whether all items in 'attributes' must match\n            (True) or any of the items must match (False). Defaults to None,\n            which means the global 'miller.MATCH_ALL' will be used.\n\n    Raises:\n        AttributeError: if 'attributes' are not attributes of 'item' and \n            'raise_error' is True (or if it is None and the global setting is\n            True).\n\n    Returns:\n        bool: whether some or all (depending on 'match_all') of 'attributes' \n            exist in 'item'.\n\n    \"\"\"\n    return base.has_elements(\n        item = item,\n        attributes = attributes,\n        checker = is_attribute,\n        raise_error = raise_error,\n        match_all = match_all)\n</code></pre>"},{"location":"reference/miller/attributes/#miller.attributes.has_class_attributes","title":"<code>has_class_attributes(item, attributes, raise_error=None, match_all=None)</code>","text":"<p>Returns whether 'attributes' exist in 'item' as class attributes.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>class or instance to examine.</p> required <code>attributes</code> <code>MutableSequence[str]</code> <p>names of attributes to check.</p> required <code>raise_error</code> <code>Optional[bool]</code> <p>whether to raise an error if any  'attributes' are not attributes of 'item' (True) or to simply  return False in such situations. Defaults to None, which means the  global 'miller.RAISE_ERRORS' setting will be used.</p> <code>None</code> <code>match_all</code> <code>Optional[bool]</code> <p>whether all items in 'attributes' must match (True) or any of the items must match (False). Defaults to None, which means the global 'miller.MATCH_ALL' will be used.</p> <code>None</code> <p>Raises:</p> Type Description <code>AttributeError</code> <p>if 'attributes' are not attributes of 'item' and  'raise_error' is True (or if it is None and the global setting is True).</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether some or all (depending on 'match_all') of 'attributes'  exist in 'item' and are the appropriate type.</p> Source code in <code>src/miller/attributes.py</code> <pre><code>def has_class_attributes(\n    item: Any, \n    attributes: MutableSequence[str], \n    raise_error: Optional[bool] = None,\n    match_all: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns whether 'attributes' exist in 'item' as class attributes.\n\n    Args:\n        item (Any): class or instance to examine.\n        attributes (MutableSequence[str]): names of attributes to check.\n        raise_error (Optional[bool]): whether to raise an error if any \n            'attributes' are not attributes of 'item' (True) or to simply \n            return False in such situations. Defaults to None, which means the \n            global 'miller.RAISE_ERRORS' setting will be used.\n        match_all (Optional[bool]): whether all items in 'attributes' must match\n            (True) or any of the items must match (False). Defaults to None,\n            which means the global 'miller.MATCH_ALL' will be used.\n\n    Raises:\n        AttributeError: if 'attributes' are not attributes of 'item' and \n            'raise_error' is True (or if it is None and the global setting is\n            True).\n\n    Returns:\n        bool: whether some or all (depending on 'match_all') of 'attributes' \n            exist in 'item' and are the appropriate type.\n\n    \"\"\"\n    return base.has_elements(\n        item = item,\n        attributes = attributes,\n        checker = is_class_attribute,\n        raise_error = raise_error,\n        match_all = match_all)\n</code></pre>"},{"location":"reference/miller/attributes/#miller.attributes.has_class_methods","title":"<code>has_class_methods(item, attributes, raise_error=None, match_all=None)</code>","text":"<p>Returns whether 'attributes' exist in 'item' as class methods.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>class or instance to examine.</p> required <code>attributes</code> <code>MutableSequence[str]</code> <p>names of attributes to check.</p> required <code>raise_error</code> <code>Optional[bool]</code> <p>whether to raise an error if any  'attributes' are not attributes of 'item' (True) or to simply  return False in such situations. Defaults to None, which means the  global 'miller.RAISE_ERRORS' setting will be used.</p> <code>None</code> <code>match_all</code> <code>Optional[bool]</code> <p>whether all items in 'attributes' must match (True) or any of the items must match (False). Defaults to None, which means the global 'miller.MATCH_ALL' will be used.</p> <code>None</code> <p>Raises:</p> Type Description <code>AttributeError</code> <p>if 'attributes' are not attributes of 'item' and  'raise_error' is True (or if it is None and the global setting is True).</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether some or all (depending on 'match_all') of 'attributes'  exist in 'item' and are the appropriate type.</p> Source code in <code>src/miller/attributes.py</code> <pre><code>def has_class_methods(\n    item: Any, \n    attributes: MutableSequence[str], \n    raise_error: Optional[bool] = None,\n    match_all: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns whether 'attributes' exist in 'item' as class methods.\n\n    Args:\n        item (Any): class or instance to examine.\n        attributes (MutableSequence[str]): names of attributes to check.\n        raise_error (Optional[bool]): whether to raise an error if any \n            'attributes' are not attributes of 'item' (True) or to simply \n            return False in such situations. Defaults to None, which means the \n            global 'miller.RAISE_ERRORS' setting will be used.\n        match_all (Optional[bool]): whether all items in 'attributes' must match\n            (True) or any of the items must match (False). Defaults to None,\n            which means the global 'miller.MATCH_ALL' will be used.\n\n    Raises:\n        AttributeError: if 'attributes' are not attributes of 'item' and \n            'raise_error' is True (or if it is None and the global setting is\n            True).\n\n    Returns:\n        bool: whether some or all (depending on 'match_all') of 'attributes' \n            exist in 'item' and are the appropriate type.\n\n    \"\"\"\n    return base.has_elements(\n        item = item,\n        attributes = attributes,\n        checker = is_class_method,\n        raise_error = raise_error,\n        match_all = match_all)\n</code></pre>"},{"location":"reference/miller/attributes/#miller.attributes.has_class_objects","title":"<code>has_class_objects(item, attributes, raise_error=None, match_all=None)</code>","text":"<p>Returns whether 'attributes' exist in 'item' as class objects.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>class or instance to examine.</p> required <code>attributes</code> <code>MutableSequence[str]</code> <p>names of attributes to check.</p> required <code>raise_error</code> <code>Optional[bool]</code> <p>whether to raise an error if any  'attributes' are not attributes of 'item' (True) or to simply  return False in such situations. Defaults to None, which means the  global 'miller.RAISE_ERRORS' setting will be used.</p> <code>None</code> <code>match_all</code> <code>Optional[bool]</code> <p>whether all items in 'attributes' must match (True) or any of the items must match (False). Defaults to None, which means the global 'miller.MATCH_ALL' will be used.</p> <code>None</code> <p>Raises:</p> Type Description <code>AttributeError</code> <p>if 'attributes' are not attributes of 'item' and  'raise_error' is True (or if it is None and the global setting is True).</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether some or all (depending on 'match_all') of 'attributes'  exist in 'item' and are the appropriate type.</p> Source code in <code>src/miller/attributes.py</code> <pre><code>def has_class_objects(\n    item: Any, \n    attributes: MutableSequence[str], \n    raise_error: Optional[bool] = None,\n    match_all: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns whether 'attributes' exist in 'item' as class objects.\n\n    Args:\n        item (Any): class or instance to examine.\n        attributes (MutableSequence[str]): names of attributes to check.\n        raise_error (Optional[bool]): whether to raise an error if any \n            'attributes' are not attributes of 'item' (True) or to simply \n            return False in such situations. Defaults to None, which means the \n            global 'miller.RAISE_ERRORS' setting will be used.\n        match_all (Optional[bool]): whether all items in 'attributes' must match\n            (True) or any of the items must match (False). Defaults to None,\n            which means the global 'miller.MATCH_ALL' will be used.\n\n    Raises:\n        AttributeError: if 'attributes' are not attributes of 'item' and \n            'raise_error' is True (or if it is None and the global setting is\n            True).\n\n    Returns:\n        bool: whether some or all (depending on 'match_all') of 'attributes' \n            exist in 'item' and are the appropriate type.\n\n    \"\"\"\n    return base.has_elements(\n        item = item,\n        attributes = attributes,\n        checker = is_class_object,\n        raise_error = raise_error,\n        match_all = match_all)\n</code></pre>"},{"location":"reference/miller/attributes/#miller.attributes.has_fields","title":"<code>has_fields(item, attributes, raise_error=None, match_all=None)</code>","text":"<p>Returns whether 'attributes' are fields in dataclass 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>class or instance to examine.</p> required <code>attributes</code> <code>MutableSequence[str]</code> <p>names of attributes to check.</p> required <code>raise_error</code> <code>Optional[bool]</code> <p>whether to raise an error if any  'attributes' are not attributes of 'item' (True) or to simply  return False in such situations. Defaults to None, which means the  global 'miller.RAISE_ERRORS' setting will be used.</p> <code>None</code> <code>match_all</code> <code>Optional[bool]</code> <p>whether all items in 'attributes' must match (True) or any of the items must match (False). Defaults to None, which means the global 'miller.MATCH_ALL' will be used.</p> <code>None</code> <p>Raises:</p> Type Description <code>AttributeError</code> <p>if 'attributes' are not attributes of 'item' and  'raise_error' is True (or if it is None and the global setting is True).</p> <code>TypeError</code> <p>if 'item' is not a dataclass.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether some or all (depending on 'match_all') of 'attributes'  exist in 'item' and are the appropriate type.</p> Source code in <code>src/miller/attributes.py</code> <pre><code>def has_fields(\n    item: dataclasses.dataclass | type[dataclasses.dataclass], \n    attributes: MutableSequence[str], \n    raise_error: Optional[bool] = None,\n    match_all: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns whether 'attributes' are fields in dataclass 'item'.\n\n    Args:\n        item (Any): class or instance to examine.\n        attributes (MutableSequence[str]): names of attributes to check.\n        raise_error (Optional[bool]): whether to raise an error if any \n            'attributes' are not attributes of 'item' (True) or to simply \n            return False in such situations. Defaults to None, which means the \n            global 'miller.RAISE_ERRORS' setting will be used.\n        match_all (Optional[bool]): whether all items in 'attributes' must match\n            (True) or any of the items must match (False). Defaults to None,\n            which means the global 'miller.MATCH_ALL' will be used.\n\n    Raises:\n        AttributeError: if 'attributes' are not attributes of 'item' and \n            'raise_error' is True (or if it is None and the global setting is\n            True).\n        TypeError: if 'item' is not a dataclass.\n\n    Returns:\n        bool: whether some or all (depending on 'match_all') of 'attributes' \n            exist in 'item' and are the appropriate type.\n\n    \"\"\"\n    if dataclasses.identity.is_dataclass(item):\n        return base.has_elements(\n            item = item,\n            attributes = attributes,\n            checker = is_field,\n            raise_error = raise_error,\n            match_all = match_all)\n    else:\n        raise TypeError('item must be a dataclass')\n</code></pre>"},{"location":"reference/miller/attributes/#miller.attributes.has_instance_attributes","title":"<code>has_instance_attributes(item, attributes, raise_error=None, match_all=None)</code>","text":"<p>Returns whether 'attributes' exist in 'item' as instance attributes.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>class or instance to examine.</p> required <code>attributes</code> <code>MutableSequence[str]</code> <p>names of attributes to check.</p> required <code>raise_error</code> <code>Optional[bool]</code> <p>whether to raise an error if any  'attributes' are not attributes of 'item' (True) or to simply  return False in such situations. Defaults to None, which means the  global 'miller.RAISE_ERRORS' setting will be used.</p> <code>None</code> <code>match_all</code> <code>Optional[bool]</code> <p>whether all items in 'attributes' must match (True) or any of the items must match (False). Defaults to None, which means the global 'miller.MATCH_ALL' will be used.</p> <code>None</code> <p>Raises:</p> Type Description <code>AttributeError</code> <p>if 'attributes' are not attributes of 'item' and  'raise_error' is True (or if it is None and the global setting is True).</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether some or all (depending on 'match_all') of 'attributes'  exist in 'item' and are the appropriate type.</p> Source code in <code>src/miller/attributes.py</code> <pre><code>def has_instance_attributes(\n    item: Any, \n    attributes: MutableSequence[str], \n    raise_error: Optional[bool] = None,\n    match_all: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns whether 'attributes' exist in 'item' as instance attributes.\n\n    Args:\n        item (Any): class or instance to examine.\n        attributes (MutableSequence[str]): names of attributes to check.\n        raise_error (Optional[bool]): whether to raise an error if any \n            'attributes' are not attributes of 'item' (True) or to simply \n            return False in such situations. Defaults to None, which means the \n            global 'miller.RAISE_ERRORS' setting will be used.\n        match_all (Optional[bool]): whether all items in 'attributes' must match\n            (True) or any of the items must match (False). Defaults to None,\n            which means the global 'miller.MATCH_ALL' will be used.\n\n    Raises:\n        AttributeError: if 'attributes' are not attributes of 'item' and \n            'raise_error' is True (or if it is None and the global setting is\n            True).\n\n    Returns:\n        bool: whether some or all (depending on 'match_all') of 'attributes' \n            exist in 'item' and are the appropriate type.\n\n    \"\"\"\n    return base.has_elements(\n        item = item,\n        attributes = attributes,\n        checker = is_instance_attribute,\n        raise_error = raise_error,\n        match_all = match_all)\n</code></pre>"},{"location":"reference/miller/attributes/#miller.attributes.has_instance_methods","title":"<code>has_instance_methods(item, attributes, raise_error=None, match_all=None)</code>","text":"<p>Returns whether 'attributes' exist in 'item' as instance methods.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>class or instance to examine.</p> required <code>attributes</code> <code>MutableSequence[str]</code> <p>names of attributes to check.</p> required <code>raise_error</code> <code>Optional[bool]</code> <p>whether to raise an error if any  'attributes' are not attributes of 'item' (True) or to simply  return False in such situations. Defaults to None, which means the  global 'miller.RAISE_ERRORS' setting will be used.</p> <code>None</code> <code>match_all</code> <code>Optional[bool]</code> <p>whether all items in 'attributes' must match (True) or any of the items must match (False). Defaults to None, which means the global 'miller.MATCH_ALL' will be used.</p> <code>None</code> <p>Raises:</p> Type Description <code>AttributeError</code> <p>if 'attributes' are not attributes of 'item' and  'raise_error' is True (or if it is None and the global setting is True).</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether some or all (depending on 'match_all') of 'attributes'  exist in 'item' and are the appropriate type.</p> Source code in <code>src/miller/attributes.py</code> <pre><code>def has_instance_methods(\n    item: Any, \n    attributes: MutableSequence[str], \n    raise_error: Optional[bool] = None,\n    match_all: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns whether 'attributes' exist in 'item' as instance methods.\n\n    Args:\n        item (Any): class or instance to examine.\n        attributes (MutableSequence[str]): names of attributes to check.\n        raise_error (Optional[bool]): whether to raise an error if any \n            'attributes' are not attributes of 'item' (True) or to simply \n            return False in such situations. Defaults to None, which means the \n            global 'miller.RAISE_ERRORS' setting will be used.\n        match_all (Optional[bool]): whether all items in 'attributes' must match\n            (True) or any of the items must match (False). Defaults to None,\n            which means the global 'miller.MATCH_ALL' will be used.\n\n    Raises:\n        AttributeError: if 'attributes' are not attributes of 'item' and \n            'raise_error' is True (or if it is None and the global setting is\n            True).\n\n    Returns:\n        bool: whether some or all (depending on 'match_all') of 'attributes' \n            exist in 'item' and are the appropriate type.\n\n    \"\"\"\n    return base.has_elements(\n        item = item,\n        attributes = attributes,\n        checker = is_instance_method,\n        raise_error = raise_error,\n        match_all = match_all)\n</code></pre>"},{"location":"reference/miller/attributes/#miller.attributes.has_instance_objects","title":"<code>has_instance_objects(item, attributes, raise_error=None, match_all=None)</code>","text":"<p>Returns whether 'attributes' exist in 'item' as instance objects.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>class or instance to examine.</p> required <code>attributes</code> <code>MutableSequence[str]</code> <p>names of attributes to check.</p> required <code>raise_error</code> <code>Optional[bool]</code> <p>whether to raise an error if any  'attributes' are not attributes of 'item' (True) or to simply  return False in such situations. Defaults to None, which means the  global 'miller.RAISE_ERRORS' setting will be used.</p> <code>None</code> <code>match_all</code> <code>Optional[bool]</code> <p>whether all items in 'attributes' must match (True) or any of the items must match (False). Defaults to None, which means the global 'miller.MATCH_ALL' will be used.</p> <code>None</code> <p>Raises:</p> Type Description <code>AttributeError</code> <p>if 'attributes' are not attributes of 'item' and  'raise_error' is True (or if it is None and the global setting is True).</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether some or all (depending on 'match_all') of 'attributes'  exist in 'item' and are the appropriate type.</p> Source code in <code>src/miller/attributes.py</code> <pre><code>def has_instance_objects(\n    item: Any, \n    attributes: MutableSequence[str], \n    raise_error: Optional[bool] = None,\n    match_all: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns whether 'attributes' exist in 'item' as instance objects.\n\n    Args:\n        item (Any): class or instance to examine.\n        attributes (MutableSequence[str]): names of attributes to check.\n        raise_error (Optional[bool]): whether to raise an error if any \n            'attributes' are not attributes of 'item' (True) or to simply \n            return False in such situations. Defaults to None, which means the \n            global 'miller.RAISE_ERRORS' setting will be used.\n        match_all (Optional[bool]): whether all items in 'attributes' must match\n            (True) or any of the items must match (False). Defaults to None,\n            which means the global 'miller.MATCH_ALL' will be used.\n\n    Raises:\n        AttributeError: if 'attributes' are not attributes of 'item' and \n            'raise_error' is True (or if it is None and the global setting is\n            True).\n\n    Returns:\n        bool: whether some or all (depending on 'match_all') of 'attributes' \n            exist in 'item' and are the appropriate type.\n\n    \"\"\"\n    return base.has_elements(\n        item = item,\n        attributes = attributes,\n        checker = is_instance_object,\n        raise_error = raise_error,\n        match_all = match_all)\n</code></pre>"},{"location":"reference/miller/attributes/#miller.attributes.has_methods","title":"<code>has_methods(item, attributes, raise_error=None, match_all=None)</code>","text":"<p>Returns whether 'attributes' exist in 'item' as methods.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>class or instance to examine.</p> required <code>attributes</code> <code>MutableSequence[str]</code> <p>names of attributes to check.</p> required <code>raise_error</code> <code>Optional[bool]</code> <p>whether to raise an error if any  'attributes' are not attributes of 'item' (True) or to simply  return False in such situations. Defaults to None, which means the  global 'miller.RAISE_ERRORS' setting will be used.</p> <code>None</code> <code>match_all</code> <code>Optional[bool]</code> <p>whether all items in 'attributes' must match (True) or any of the items must match (False). Defaults to None, which means the global 'miller.MATCH_ALL' will be used.</p> <code>None</code> <p>Raises:</p> Type Description <code>AttributeError</code> <p>if 'attributes' are not attributes of 'item' and  'raise_error' is True (or if it is None and the global setting is True).</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether some or all (depending on 'match_all') of 'attributes'  exist in 'item' and are the appropriate type.</p> Source code in <code>src/miller/attributes.py</code> <pre><code>def has_methods(\n    item: Any, \n    attributes: MutableSequence[str], \n    raise_error: Optional[bool] = None,\n    match_all: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns whether 'attributes' exist in 'item' as methods.\n\n    Args:\n        item (Any): class or instance to examine.\n        attributes (MutableSequence[str]): names of attributes to check.\n        raise_error (Optional[bool]): whether to raise an error if any \n            'attributes' are not attributes of 'item' (True) or to simply \n            return False in such situations. Defaults to None, which means the \n            global 'miller.RAISE_ERRORS' setting will be used.\n        match_all (Optional[bool]): whether all items in 'attributes' must match\n            (True) or any of the items must match (False). Defaults to None,\n            which means the global 'miller.MATCH_ALL' will be used.\n\n    Raises:\n        AttributeError: if 'attributes' are not attributes of 'item' and \n            'raise_error' is True (or if it is None and the global setting is\n            True).\n\n    Returns:\n        bool: whether some or all (depending on 'match_all') of 'attributes' \n            exist in 'item' and are the appropriate type.\n\n    \"\"\"\n    return base.has_elements(\n        item = item,\n        attributes = attributes,\n        checker = is_method,\n        raise_error = raise_error,\n        match_all = match_all)\n</code></pre>"},{"location":"reference/miller/attributes/#miller.attributes.has_objects","title":"<code>has_objects(item, attributes, raise_error=None, match_all=None)</code>","text":"<p>Returns whether 'attributes' exist in 'item' as simple data objects.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>class or instance to examine.</p> required <code>attributes</code> <code>MutableSequence[str]</code> <p>names of attributes to check.</p> required <code>raise_error</code> <code>Optional[bool]</code> <p>whether to raise an error if any  'attributes' are not attributes of 'item' (True) or to simply  return False in such situations. Defaults to None, which means the  global 'miller.RAISE_ERRORS' setting will be used.</p> <code>None</code> <code>match_all</code> <code>Optional[bool]</code> <p>whether all items in 'attributes' must match (True) or any of the items must match (False). Defaults to None, which means the global 'miller.MATCH_ALL' will be used.</p> <code>None</code> <p>Raises:</p> Type Description <code>AttributeError</code> <p>if 'attributes' are not attributes of 'item' and  'raise_error' is True (or if it is None and the global setting is True).</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether some or all (depending on 'match_all') of 'attributes'  exist in 'item' and are the appropriate type.</p> Source code in <code>src/miller/attributes.py</code> <pre><code>def has_objects(\n    item: Any, \n    attributes: MutableSequence[str], \n    raise_error: Optional[bool] = None,\n    match_all: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns whether 'attributes' exist in 'item' as simple data objects.\n\n    Args:\n        item (Any): class or instance to examine.\n        attributes (MutableSequence[str]): names of attributes to check.\n        raise_error (Optional[bool]): whether to raise an error if any \n            'attributes' are not attributes of 'item' (True) or to simply \n            return False in such situations. Defaults to None, which means the \n            global 'miller.RAISE_ERRORS' setting will be used.\n        match_all (Optional[bool]): whether all items in 'attributes' must match\n            (True) or any of the items must match (False). Defaults to None,\n            which means the global 'miller.MATCH_ALL' will be used.\n\n    Raises:\n        AttributeError: if 'attributes' are not attributes of 'item' and \n            'raise_error' is True (or if it is None and the global setting is\n            True).\n\n    Returns:\n        bool: whether some or all (depending on 'match_all') of 'attributes' \n            exist in 'item' and are the appropriate type.\n\n    \"\"\"\n    return base.has_elements(\n        item = item,\n        attributes = attributes,\n        checker = is_object,\n        raise_error = raise_error,\n        match_all = match_all)\n</code></pre>"},{"location":"reference/miller/attributes/#miller.attributes.has_properties","title":"<code>has_properties(item, attributes, raise_error=None, match_all=None)</code>","text":"<p>Returns whether 'attributes' exist in 'item' as properties.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>class or instance to examine.</p> required <code>attributes</code> <code>MutableSequence[str]</code> <p>names of attributes to check.</p> required <code>raise_error</code> <code>Optional[bool]</code> <p>whether to raise an error if any  'attributes' are not attributes of 'item' (True) or to simply  return False in such situations. Defaults to None, which means the  global 'miller.RAISE_ERRORS' setting will be used.</p> <code>None</code> <code>match_all</code> <code>Optional[bool]</code> <p>whether all items in 'attributes' must match (True) or any of the items must match (False). Defaults to None, which means the global 'miller.MATCH_ALL' will be used.</p> <code>None</code> <p>Raises:</p> Type Description <code>AttributeError</code> <p>if 'attributes' are not attributes of 'item' and  'raise_error' is True (or if it is None and the global setting is True).</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether some or all (depending on 'match_all') of 'attributes'  exist in 'item' and are the appropriate type.</p> Source code in <code>src/miller/attributes.py</code> <pre><code>def has_properties(\n    item: Any, \n    attributes: MutableSequence[str], \n    raise_error: Optional[bool] = None,\n    match_all: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns whether 'attributes' exist in 'item' as properties.\n\n    Args:\n        item (Any): class or instance to examine.\n        attributes (MutableSequence[str]): names of attributes to check.\n        raise_error (Optional[bool]): whether to raise an error if any \n            'attributes' are not attributes of 'item' (True) or to simply \n            return False in such situations. Defaults to None, which means the \n            global 'miller.RAISE_ERRORS' setting will be used.\n        match_all (Optional[bool]): whether all items in 'attributes' must match\n            (True) or any of the items must match (False). Defaults to None,\n            which means the global 'miller.MATCH_ALL' will be used.\n\n    Raises:\n        AttributeError: if 'attributes' are not attributes of 'item' and \n            'raise_error' is True (or if it is None and the global setting is\n            True).\n\n    Returns:\n        bool: whether some or all (depending on 'match_all') of 'attributes' \n            exist in 'item' and are the appropriate type.\n\n    \"\"\"\n    return base.has_elements(\n        item = item,\n        attributes = attributes,\n        checker = is_property,\n        raise_error = raise_error,\n        match_all = match_all)\n</code></pre>"},{"location":"reference/miller/attributes/#miller.attributes.has_traits","title":"<code>has_traits(item, attributes=None, methods=None, properties=None, objects=None, raise_error=None, match_all=None)</code>","text":"<p>Returns if 'item' has all or some of the passed traits.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>object to examine.</p> required <code>attributes</code> <code>MutableSequence[str]</code> <p>names of attributes to check.</p> <code>None</code> <code>methods</code> <code>MutableSequence[str]</code> <p>name(s) of methods to check.       </p> <code>None</code> <code>properties</code> <code>MutableSequence[str]</code> <p>names of properties to check.</p> <code>None</code> <code>objects</code> <code>MutableSequence[str]</code> <p>names of objects to check.</p> <code>None</code> <code>raise_error</code> <code>Optional[bool]</code> <p>whether to raise an error if any of the  traits are not an attribute of 'item' (True) or to simply  return False in such situations. Defaults to None, which means the  global 'miller.RAISE_ERRORS' setting will be used.</p> <code>None</code> <code>match_all</code> <code>Optional[bool]</code> <p>whether all items in the traits must match (True) or any of the items must match (False). Defaults to None, which means the global 'miller.MATCH_ALL' will be used.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether all passed arguments exist in 'item'.</p> Source code in <code>src/miller/attributes.py</code> <pre><code>def has_traits(\n    item: Any,\n    attributes: Optional[MutableSequence[str]] = None,\n    methods: Optional[MutableSequence[str]] = None,\n    properties: Optional[MutableSequence[str]] = None, \n    objects: Optional[MutableSequence[str]] = None,\n    raise_error: Optional[bool] = None,\n    match_all: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns if 'item' has all or some of the passed traits.\n\n    Args:\n        item (Any): object to examine.\n        attributes (MutableSequence[str]): names of attributes to check.\n        methods (MutableSequence[str]): name(s) of methods to check.       \n        properties (MutableSequence[str]): names of properties to check.\n        objects (MutableSequence[str]): names of objects to check.\n        raise_error (Optional[bool]): whether to raise an error if any of the \n            traits are not an attribute of 'item' (True) or to simply \n            return False in such situations. Defaults to None, which means the \n            global 'miller.RAISE_ERRORS' setting will be used.\n        match_all (Optional[bool]): whether all items in the traits must match\n            (True) or any of the items must match (False). Defaults to None,\n            which means the global 'miller.MATCH_ALL' will be used.\n\n    Returns:\n        bool: whether all passed arguments exist in 'item'.    \n\n    \"\"\"\n    attributes = attributes or []\n    methods = methods or []\n    properties = properties or []\n    objects = objects or []\n    kwargs = dict(raise_error = raise_error, match_all = match_all)\n    return (\n        has_attributes(item, attributes = attributes, **kwargs)\n        and has_methods(item, attributes = methods, **kwargs)\n        and has_properties(item, attributes = properties, **kwargs)\n        and has_objects(item, attributes = objects, **kwargs))\n</code></pre>"},{"location":"reference/miller/attributes/#miller.attributes.is_attribute","title":"<code>is_attribute(item, attribute, raise_error=None)</code>","text":"<p>Returns if 'attribute' is an attribute of 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>class or instance to examine.</p> required <code>attribute</code> <code>str</code> <p>name of attribute to examine.</p> required <code>raise_error</code> <code>Optional[bool]</code> <p>whether to raise an error if 'attribute'  is not an attribute of 'item' (True) or to simply return False in such situations. Defaults to None, which means the global  'miller.RAISE_ERRORS' setting will be used.</p> <code>None</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>if 'item' is not the appropriate type and 'raise_error' is  True (or if it is None and the global setting is True).</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether 'attribute' is an attribute.</p> Source code in <code>src/miller/attributes.py</code> <pre><code>def is_attribute(\n    item: Any,\n    attribute: str, \n    raise_error: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns if 'attribute' is an attribute of 'item'.\n\n    Args:\n        item (Any): class or instance to examine.\n        attribute (str): name of attribute to examine.\n        raise_error (Optional[bool]): whether to raise an error if 'attribute' \n            is not an attribute of 'item' (True) or to simply return False in\n            such situations. Defaults to None, which means the global \n            'miller.RAISE_ERRORS' setting will be used.\n\n    Raises:\n        TypeError: if 'item' is not the appropriate type and 'raise_error' is \n            True (or if it is None and the global setting is True).\n\n    Returns:\n        bool: whether 'attribute' is an attribute.\n\n    \"\"\"\n    return base.is_kind_class(\n        item = item,\n        kind = attribute,\n        checker = hasattr,\n        raise_error = raise_error)\n</code></pre>"},{"location":"reference/miller/attributes/#miller.attributes.is_class_attribute","title":"<code>is_class_attribute(item, attribute, raise_error=None)</code>","text":"<p>Returns if 'attribute' is a class attribute of 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>class or instance to examine.</p> required <code>attribute</code> <code>str</code> <p>name of attribute to examine.</p> required <code>raise_error</code> <code>Optional[bool]</code> <p>whether to raise an error if 'attribute'  is not an attribute of 'item' (True) or to simply return False in such situations. Defaults to None, which means the global  'miller.RAISE_ERRORS' setting will be used.</p> <code>None</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>if 'item' is not the appropriate type and 'raise_error' is  True (or if it is None and the global setting is True).</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether 'attribute' is an attribute and the appropriate type.</p> Source code in <code>src/miller/attributes.py</code> <pre><code>def is_class_attribute(\n    item: Any,\n    attribute: str, \n    raise_error: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns if 'attribute' is a class attribute of 'item'.\n\n    Args:\n        item (Any): class or instance to examine.\n        attribute (str): name of attribute to examine.\n        raise_error (Optional[bool]): whether to raise an error if 'attribute' \n            is not an attribute of 'item' (True) or to simply return False in\n            such situations. Defaults to None, which means the global \n            'miller.RAISE_ERRORS' setting will be used.\n\n    Raises:\n        TypeError: if 'item' is not the appropriate type and 'raise_error' is \n            True (or if it is None and the global setting is True).\n\n    Returns:\n        bool: whether 'attribute' is an attribute and the appropriate type.\n\n    \"\"\" \n    item = item if inspect.isclass(item) else item.__class__\n    return base.is_kind_class(\n        item = item,\n        kind = attribute,\n        checker = hasattr,\n        raise_error = raise_error)\n</code></pre>"},{"location":"reference/miller/attributes/#miller.attributes.is_class_method","title":"<code>is_class_method(item, attribute, raise_error=None)</code>","text":"<p>Returns if 'attribute' is a class method of 'item'.</p> <p>The code used in this function is adapted from: https://stackoverflow.com/questions/19227724/check-if-a-function-uses-classmethod</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>class or instance to examine.</p> required <code>attribute</code> <code>str</code> <p>name of attribute to examine.</p> required <code>raise_error</code> <code>Optional[bool]</code> <p>whether to raise an error if 'attribute'  is not an attribute of 'item' (True) or to simply return False in such situations. Defaults to None, which means the global  'miller.RAISE_ERRORS' setting will be used.</p> <code>None</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>if 'item' is not the appropriate type and 'raise_error' is  True (or if it is None and the global setting is True).</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether 'attribute' is an attribute and the appropriate type.</p> Source code in <code>src/miller/attributes.py</code> <pre><code>def is_class_method(\n    item: Any,\n    attribute: str, \n    raise_error: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns if 'attribute' is a class method of 'item'.\n\n    The code used in this function is adapted from:\n    https://stackoverflow.com/questions/19227724/check-if-a-function-uses-classmethod\n\n    Args:\n        item (Any): class or instance to examine.\n        attribute (str): name of attribute to examine.\n        raise_error (Optional[bool]): whether to raise an error if 'attribute' \n            is not an attribute of 'item' (True) or to simply return False in\n            such situations. Defaults to None, which means the global \n            'miller.RAISE_ERRORS' setting will be used.\n\n    Raises:\n        TypeError: if 'item' is not the appropriate type and 'raise_error' is \n            True (or if it is None and the global setting is True).\n\n    Returns:\n        bool: whether 'attribute' is an attribute and the appropriate type.\n\n    \"\"\"\n    if raise_error is None:\n        raise_error = configuration.RAISE_ERRORS    \n    item = item if inspect.isclass(item) else item.__class__\n    if not hasattr(item, attribute) and raise_error:\n        raise AttributeError(f'{attribute} is not an method of {item}')\n    elif is_method(item, attribute):\n        method = getattr(item, attribute)\n        bound_to = getattr(method, '__self__', None)\n        if not isinstance(bound_to, type):\n            return False\n        name = method.__name__\n        for cls in bound_to.__mro__:\n            descriptor = vars(cls).get(name)\n            if descriptor is not None:\n                return isinstance(descriptor, classmethod)\n    return False    \n</code></pre>"},{"location":"reference/miller/attributes/#miller.attributes.is_class_object","title":"<code>is_class_object(item, attribute, raise_error=None)</code>","text":"<p>Returns if 'attribute' is a class object of 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>class or instance to examine.</p> required <code>attribute</code> <code>str</code> <p>name of attribute to examine.</p> required <code>raise_error</code> <code>Optional[bool]</code> <p>whether to raise an error if 'attribute'  is not an attribute of 'item' (True) or to simply return False in such situations. Defaults to None, which means the global  'miller.RAISE_ERRORS' setting will be used.</p> <code>None</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>if 'item' is not the appropriate type and 'raise_error' is  True (or if it is None and the global setting is True).</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether 'attribute' is an attribute and the appropriate type.</p> Source code in <code>src/miller/attributes.py</code> <pre><code>def is_class_object(\n    item: Any,\n    attribute: str, \n    raise_error: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns if 'attribute' is a class object of 'item'.\n\n    Args:\n        item (Any): class or instance to examine.\n        attribute (str): name of attribute to examine.\n        raise_error (Optional[bool]): whether to raise an error if 'attribute' \n            is not an attribute of 'item' (True) or to simply return False in\n            such situations. Defaults to None, which means the global \n            'miller.RAISE_ERRORS' setting will be used.\n\n    Raises:\n        TypeError: if 'item' is not the appropriate type and 'raise_error' is \n            True (or if it is None and the global setting is True).\n\n    Returns:\n        bool: whether 'attribute' is an attribute and the appropriate type.\n\n    \"\"\"\n    if raise_error is None:\n        raise_error = configuration.RAISE_ERRORS    \n    owner = item if inspect.isclass(item) else item.__class__\n    if not hasattr(item, attribute) and raise_error:\n        raise AttributeError(f'{attribute} is not an attribute of {item}')\n    else:\n        return (\n            hasattr(owner, attribute)\n            and not is_method(item, attribute, raise_error = False)\n            and not is_property(owner, attribute, raise_error = False))\n</code></pre>"},{"location":"reference/miller/attributes/#miller.attributes.is_field","title":"<code>is_field(item, attribute, raise_error=None)</code>","text":"<p>Returns if 'attribute' is a field of 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>dataclass | type[dataclasses.dataclass]</code> <p>dataclass or  dataclass instance to examine.</p> required <code>attribute</code> <code>str</code> <p>name of attribute to examine.</p> required <code>raise_error</code> <code>Optional[bool]</code> <p>whether to raise an error if 'attribute'  is not an attribute of 'item' (True) or to simply return False in such situations. Defaults to None, which means the global  'miller.RAISE_ERRORS' setting will be used.</p> <code>None</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>if 'item' is not the appropriate type and 'raise_error' is  True (or if it is None and the global setting is True).</p> <code>TypeError</code> <p>if 'item' is not a dataclass.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether 'attribute' is an attribute and the appropriate type.</p> Source code in <code>src/miller/attributes.py</code> <pre><code>def is_field(\n    item: Any,\n    attribute: str, \n    raise_error: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns if 'attribute' is a field of 'item'.\n\n    Args:\n        item (dataclasses.dataclass | type[dataclasses.dataclass]): dataclass or \n            dataclass instance to examine.\n        attribute (str): name of attribute to examine.\n        raise_error (Optional[bool]): whether to raise an error if 'attribute' \n            is not an attribute of 'item' (True) or to simply return False in\n            such situations. Defaults to None, which means the global \n            'miller.RAISE_ERRORS' setting will be used.\n\n    Raises:\n        TypeError: if 'item' is not the appropriate type and 'raise_error' is \n            True (or if it is None and the global setting is True).\n        TypeError: if 'item' is not a dataclass.\n\n    Returns:\n        bool: whether 'attribute' is an attribute and the appropriate type.\n\n    \"\"\"\n    if dataclasses.identity.is_dataclass(item):\n        return base.is_kind_class(\n            checker = dataclasses.fields,\n            raise_error = raise_error,\n            item = getattr(item, attribute))\n    else:\n        raise TypeError('item must be a dataclass')\n</code></pre>"},{"location":"reference/miller/attributes/#miller.attributes.is_instance_attribute","title":"<code>is_instance_attribute(item, attribute, raise_error=None)</code>","text":"<p>Returns if 'attribute' is an instance attribute of 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>class or instance to examine.</p> required <code>attribute</code> <code>str</code> <p>name of attribute to examine.</p> required <code>raise_error</code> <code>Optional[bool]</code> <p>whether to raise an error if 'attribute'  is not an attribute of 'item' (True) or to simply return False in such situations. Defaults to None, which means the global  'miller.RAISE_ERRORS' setting will be used.</p> <code>None</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>if 'item' is not the appropriate type and 'raise_error' is  True (or if it is None and the global setting is True).</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether 'attribute' is an attribute and the appropriate type.</p> Source code in <code>src/miller/attributes.py</code> <pre><code>def is_instance_attribute(\n    item: object,\n    attribute: str, \n    raise_error: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns if 'attribute' is an instance attribute of 'item'.\n\n    Args:\n        item (Any): class or instance to examine.\n        attribute (str): name of attribute to examine.\n        raise_error (Optional[bool]): whether to raise an error if 'attribute' \n            is not an attribute of 'item' (True) or to simply return False in\n            such situations. Defaults to None, which means the global \n            'miller.RAISE_ERRORS' setting will be used.\n\n    Raises:\n        TypeError: if 'item' is not the appropriate type and 'raise_error' is \n            True (or if it is None and the global setting is True).\n\n    Returns:\n        bool: whether 'attribute' is an attribute and the appropriate type.\n\n    \"\"\"\n    if raise_error is None:\n        raise_error = configuration.RAISE_ERRORS\n    owner = item if inspect.isclass(item) else item.__class__\n    if not hasattr(item, attribute) and raise_error:\n        raise AttributeError(f'{attribute} is not an attribute of {item}')\n    else:\n        return (\n            hasattr(item, attribute) \n            and not is_class_attribute(owner, attribute, raise_error = False))\n</code></pre>"},{"location":"reference/miller/attributes/#miller.attributes.is_instance_method","title":"<code>is_instance_method(item, attribute, raise_error=None)</code>","text":"<p>Returns if 'attribute' is an instance method of 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>class or instance to examine.</p> required <code>attribute</code> <code>str</code> <p>name of attribute to examine.</p> required <code>raise_error</code> <code>Optional[bool]</code> <p>whether to raise an error if 'attribute'  is not an attribute of 'item' (True) or to simply return False in such situations. Defaults to None, which means the global  'miller.RAISE_ERRORS' setting will be used.</p> <code>None</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>if 'item' is not the appropriate type and 'raise_error' is  True (or if it is None and the global setting is True).</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether 'attribute' is an attribute and the appropriate type.</p> Source code in <code>src/miller/attributes.py</code> <pre><code>def is_instance_method(\n    item: object,\n    attribute: str, \n    raise_error: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns if 'attribute' is an instance method of 'item'.\n\n    Args:\n        item (Any): class or instance to examine.\n        attribute (str): name of attribute to examine.\n        raise_error (Optional[bool]): whether to raise an error if 'attribute' \n            is not an attribute of 'item' (True) or to simply return False in\n            such situations. Defaults to None, which means the global \n            'miller.RAISE_ERRORS' setting will be used.\n\n    Raises:\n        TypeError: if 'item' is not the appropriate type and 'raise_error' is \n            True (or if it is None and the global setting is True).\n\n    Returns:\n        bool: whether 'attribute' is an attribute and the appropriate type.\n\n    \"\"\"\n    if raise_error is None:\n        raise_error = configuration.RAISE_ERRORS    \n    if not hasattr(item, attribute) and raise_error:\n        raise AttributeError(f'{attribute} is not an method of {item}')\n    else:\n        return (\n            hasattr(item, attribute) \n            and is_method(item, attribute, raise_error = False)\n            and not is_class_method(item, attribute, raise_error = False))\n</code></pre>"},{"location":"reference/miller/attributes/#miller.attributes.is_instance_object","title":"<code>is_instance_object(item, attribute, raise_error=None)</code>","text":"<p>Returns if 'attribute' is an instance object of 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>class or instance to examine.</p> required <code>attribute</code> <code>str</code> <p>name of attribute to examine.</p> required <code>raise_error</code> <code>Optional[bool]</code> <p>whether to raise an error if 'attribute'  is not an attribute of 'item' (True) or to simply return False in such situations. Defaults to None, which means the global  'miller.RAISE_ERRORS' setting will be used.</p> <code>None</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>if 'item' is not the appropriate type and 'raise_error' is  True (or if it is None and the global setting is True).</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether 'attribute' is an attribute and the appropriate type.</p> Source code in <code>src/miller/attributes.py</code> <pre><code>def is_instance_object(\n    item: object,\n    attribute: str, \n    raise_error: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns if 'attribute' is an instance object of 'item'.\n\n    Args:\n        item (Any): class or instance to examine.\n        attribute (str): name of attribute to examine.\n        raise_error (Optional[bool]): whether to raise an error if 'attribute' \n            is not an attribute of 'item' (True) or to simply return False in\n            such situations. Defaults to None, which means the global \n            'miller.RAISE_ERRORS' setting will be used.\n\n    Raises:\n        TypeError: if 'item' is not the appropriate type and 'raise_error' is \n            True (or if it is None and the global setting is True).\n\n    Returns:\n        bool: whether 'attribute' is an attribute and the appropriate type.\n\n    \"\"\"\n    if raise_error is None:\n        raise_error = configuration.RAISE_ERRORS    \n    owner = item if inspect.isclass(item) else item.__class__\n    if not hasattr(item, attribute) and raise_error:\n        raise AttributeError(f'{attribute} is not an attribute of {item}')\n    else:\n        return (\n            hasattr(item, attribute)\n            and not is_class_attribute(owner, attribute, raise_error = False)\n            and not is_method(item, attribute, raise_error = False)\n            and not is_property(item, attribute, raise_error = False))\n</code></pre>"},{"location":"reference/miller/attributes/#miller.attributes.is_method","title":"<code>is_method(item, attribute, raise_error=None)</code>","text":"<p>Returns if 'attribute' is a method of 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>class or instance to examine.</p> required <code>attribute</code> <code>str</code> <p>name of attribute to examine.</p> required <code>raise_error</code> <code>Optional[bool]</code> <p>whether to raise an error if 'attribute'  is not an attribute of 'item' (True) or to simply return False in such situations. Defaults to None, which means the global  'miller.RAISE_ERRORS' setting will be used.</p> <code>None</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>if 'item' is not the appropriate type and 'raise_error' is  True (or if it is None and the global setting is True).</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether 'attribute' is an attribute and the appropriate type.</p> Source code in <code>src/miller/attributes.py</code> <pre><code>def is_method(\n    item: Any,\n    attribute: str, \n    raise_error: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns if 'attribute' is a method of 'item'.\n\n    Args:\n        item (Any): class or instance to examine.\n        attribute (str): name of attribute to examine.\n        raise_error (Optional[bool]): whether to raise an error if 'attribute' \n            is not an attribute of 'item' (True) or to simply return False in\n            such situations. Defaults to None, which means the global \n            'miller.RAISE_ERRORS' setting will be used.\n\n    Raises:\n        TypeError: if 'item' is not the appropriate type and 'raise_error' is \n            True (or if it is None and the global setting is True).\n\n    Returns:\n        bool: whether 'attribute' is an attribute and the appropriate type.\n\n    \"\"\"\n    return base.is_kind_class(\n        checker = inspect.ismethod,\n        raise_error = raise_error,\n        item = getattr(item, attribute))    \n</code></pre>"},{"location":"reference/miller/attributes/#miller.attributes.is_object","title":"<code>is_object(item, attribute, raise_error=None)</code>","text":"<p>Returns if 'attribute' is a data object of 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>class or instance to examine.</p> required <code>attribute</code> <code>str</code> <p>name of attribute to examine.</p> required <code>raise_error</code> <code>Optional[bool]</code> <p>whether to raise an error if 'attribute'  is not an attribute of 'item' (True) or to simply return False in such situations. Defaults to None, which means the global  'miller.RAISE_ERRORS' setting will be used.</p> <code>None</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>if 'item' is not the appropriate type and 'raise_error' is  True (or if it is None and the global setting is True).</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether 'attribute' is an attribute and the appropriate type.</p> Source code in <code>src/miller/attributes.py</code> <pre><code>def is_object(\n    item: Any,\n    attribute: str, \n    raise_error: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns if 'attribute' is a data object of 'item'.\n\n    Args:\n        item (Any): class or instance to examine.\n        attribute (str): name of attribute to examine.\n        raise_error (Optional[bool]): whether to raise an error if 'attribute' \n            is not an attribute of 'item' (True) or to simply return False in\n            such situations. Defaults to None, which means the global \n            'miller.RAISE_ERRORS' setting will be used.\n\n    Raises:\n        TypeError: if 'item' is not the appropriate type and 'raise_error' is \n            True (or if it is None and the global setting is True).\n\n    Returns:\n        bool: whether 'attribute' is an attribute and the appropriate type.\n\n    \"\"\"\n    if raise_error is None:\n        raise_error = configuration.RAISE_ERRORS    \n    if not hasattr(item, attribute) and raise_error:\n        raise AttributeError(f'{attribute} is not an attribute of {item}')\n    else:\n        return(\n            hasattr(item, attribute)\n            and not is_method(item, attribute, raise_error = False)\n            and not is_property(item, attribute, raise_error = False))\n</code></pre>"},{"location":"reference/miller/attributes/#miller.attributes.is_property","title":"<code>is_property(item, attribute, raise_error=None)</code>","text":"<p>Returns if 'attribute' is a property of 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>class or instance to examine.</p> required <code>attribute</code> <code>str</code> <p>name of attribute to examine.</p> required <code>raise_error</code> <code>Optional[bool]</code> <p>whether to raise an error if 'attribute'  is not an attribute of 'item' (True) or to simply return False in such situations. Defaults to None, which means the global  'miller.RAISE_ERRORS' setting will be used.</p> <code>None</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>if 'item' is not the appropriate type and 'raise_error' is  True (or if it is None and the global setting is True).</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether 'attribute' is an attribute and the appropriate type.</p> Source code in <code>src/miller/attributes.py</code> <pre><code>def is_property(\n    item: Any,\n    attribute: str, \n    raise_error: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns if 'attribute' is a property of 'item'.\n\n    Args:\n        item (Any): class or instance to examine.\n        attribute (str): name of attribute to examine.\n        raise_error (Optional[bool]): whether to raise an error if 'attribute' \n            is not an attribute of 'item' (True) or to simply return False in\n            such situations. Defaults to None, which means the global \n            'miller.RAISE_ERRORS' setting will be used.\n\n    Raises:\n        TypeError: if 'item' is not the appropriate type and 'raise_error' is \n            True (or if it is None and the global setting is True).\n\n    Returns:\n        bool: whether 'attribute' is an attribute and the appropriate type.\n\n    \"\"\"\n    if raise_error is None:\n        raise_error = configuration.RAISE_ERRORS    \n    item = item if inspect.isclass(item) else item.__class__\n    if not hasattr(item, attribute) and raise_error:\n        raise AttributeError(f'{attribute} is not an attribute of {item}')\n    else:\n        return (\n            hasattr(item, attribute) \n            and isinstance(getattr(item, attribute), property))\n</code></pre>"},{"location":"reference/miller/attributes/#miller.attributes.map_attributes","title":"<code>map_attributes(item, include_private=False)</code>","text":"<p>Returns dict of attributes of 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to examine.</p> required <code>include_private</code> <code>bool</code> <p>whether to include items that begin with '_' (True) or to exclude them (False). Defauls to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: dict of attributes in 'item' (keys are attribute names  and values are attribute values).</p> Source code in <code>src/miller/attributes.py</code> <pre><code>def map_attributes(\n    item: object, \n    include_private: bool = False) -&gt; dict[str, Any]:\n\"\"\"Returns dict of attributes of 'item'.\n\n    Args:\n        item (Any): item to examine.\n        include_private (bool): whether to include items that begin with '_'\n            (True) or to exclude them (False). Defauls to False.\n\n    Returns:\n        dict[str, Any]: dict of attributes in 'item' (keys are attribute names \n            and values are attribute values).\n\n    \"\"\"\n    attributes = name_attributes(item, include_private = include_private)\n    values = [getattr(item, m) for m in attributes]\n    return dict(zip(attributes, values))\n</code></pre>"},{"location":"reference/miller/attributes/#miller.attributes.map_fields","title":"<code>map_fields(item, include_private=False)</code>","text":"<p>Returns whether 'attributes' exist in dataclass 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>dataclass | type[dataclasses.dataclass]</code> <p>dataclass or  dataclass instance to examine.</p> required <code>include_private</code> <code>bool</code> <p>whether to include items that begin with '_' (True) or to exclude them (False). Defauls to False.    </p> <code>False</code> <p>Raises:     TypeError: if 'item' is not a dataclass.</p> <p>Returns:</p> Type Description <code>dict[str, Field]</code> <p>dict[str, dataclasses.Field]: dict of fields in 'item' (keys are  attribute names and values are dataclass fields).</p> Source code in <code>src/miller/attributes.py</code> <pre><code>def map_fields(\n    item: dataclasses.dataclass | type[dataclasses.dataclass], \n    include_private: bool = False) -&gt; dict[str, dataclasses.Field]:\n\"\"\"Returns whether 'attributes' exist in dataclass 'item'.\n\n    Args:\n        item (dataclasses.dataclass | type[dataclasses.dataclass]): dataclass or \n            dataclass instance to examine.\n        include_private (bool): whether to include items that begin with '_'\n            (True) or to exclude them (False). Defauls to False.    \n    Raises:\n        TypeError: if 'item' is not a dataclass.\n\n    Returns:\n        dict[str, dataclasses.Field]: dict of fields in 'item' (keys are \n            attribute names and values are dataclass fields).\n\n    \"\"\"\n    if dataclasses.identify.identity.is_dataclass(item):\n        attributes = {f.name: f for f in dataclasses.fields(item)}\n        if not include_private:\n            attributes = camina.drop_privates(attributes)\n        return attributes\n    else:\n        raise TypeError('item must be a dataclass')\n</code></pre>"},{"location":"reference/miller/attributes/#miller.attributes.map_methods","title":"<code>map_methods(item, include_private=False)</code>","text":"<p>Returns dict of methods of 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>object to examine.</p> required <code>include_private</code> <code>bool</code> <p>whether to include items that begin with '_' (True) or to exclude them (False). Defauls to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, MethodType]</code> <p>dict[str, types.MethodType]: dict of methods in 'item' (keys are method  names and values are methods).</p> Source code in <code>src/miller/attributes.py</code> <pre><code>def map_methods(\n    item: Any, \n    include_private: bool = False) -&gt; dict[str, types.MethodType]:\n\"\"\"Returns dict of methods of 'item'.\n\n    Args:\n        item (Any): object to examine.\n        include_private (bool): whether to include items that begin with '_'\n            (True) or to exclude them (False). Defauls to False.\n\n    Returns:\n        dict[str, types.MethodType]: dict of methods in 'item' (keys are method \n            names and values are methods).\n\n    \"\"\" \n    methods = name_methods(item, include_private = include_private)\n    return [getattr(item, m) for m in methods]\n</code></pre>"},{"location":"reference/miller/attributes/#miller.attributes.map_objects","title":"<code>map_objects(item, include_private=False)</code>","text":"<p>Returns dict of attributes of 'item' that are not methods or properties.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>object</code> <p>instance to examine.</p> required <code>include_private</code> <code>bool</code> <p>whether to include items that begin with '_' (True) or to exclude them (False). Defauls to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: dict of attributes in 'item' (keys are attribute names  and values are attribute values) that are not methods or properties.</p> Source code in <code>src/miller/attributes.py</code> <pre><code>def map_objects(\n    item: object, \n    include_private: bool = False) -&gt; dict[str, Any]:\n\"\"\"Returns dict of attributes of 'item' that are not methods or properties.\n\n    Args:\n        item (object): instance to examine.\n        include_private (bool): whether to include items that begin with '_'\n            (True) or to exclude them (False). Defauls to False.\n\n    Returns:\n        dict[str, Any]: dict of attributes in 'item' (keys are attribute names \n            and values are attribute values) that are not methods or properties.\n\n    \"\"\"\n    attributes = name_attributes(item, include_private = include_private)\n    methods = name_methods(item, include_private = include_private)\n    properties = name_properties(item, include_private = include_private)\n    objects = [\n        a for a in attributes if a not in methods and a not in properties]\n    values = [getattr(item, m) for m in objects]\n    return dict(zip(objects, values))\n</code></pre>"},{"location":"reference/miller/attributes/#miller.attributes.map_properties","title":"<code>map_properties(item, include_private=False)</code>","text":"<p>Returns properties of 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>object</code> <p>instance to examine.</p> required <code>include_private</code> <code>bool</code> <p>whether to include items that begin with '_' (True) or to exclude them (False). Defauls to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: dict of properties in 'item' (keys are property names  and values are property values).</p> Source code in <code>src/miller/attributes.py</code> <pre><code>def map_properties(\n    item: object, \n    include_private: bool = False) -&gt; dict[str, Any]:\n\"\"\"Returns properties of 'item'.\n\n    Args:\n        item (object): instance to examine.\n        include_private (bool): whether to include items that begin with '_'\n            (True) or to exclude them (False). Defauls to False.\n\n    Returns:\n        dict[str, Any]: dict of properties in 'item' (keys are property names \n            and values are property values).\n\n    \"\"\"    \n    properties = name_properties(item, include_private = include_private)\n    values = [getattr(item, p) for p in properties]\n    return dict(zip(properties, values))\n</code></pre>"},{"location":"reference/miller/attributes/#miller.attributes.map_signatures","title":"<code>map_signatures(item, include_private=False)</code>","text":"<p>Returns dict of method signatures of 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>object to examine.</p> required <code>include_private</code> <code>bool</code> <p>whether to include items that begin with '_' (True) or to exclude them (False). Defauls to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Signature]</code> <p>dict[str, inspect.Signature]: dict of method signatures in 'item' (keys  are method names and values are method signatures).</p> Source code in <code>src/miller/attributes.py</code> <pre><code>def map_signatures(\n    item: Any, \n    include_private: bool = False) -&gt; dict[str, inspect.Signature]:\n\"\"\"Returns dict of method signatures of 'item'.\n\n    Args:\n        item (Any): object to examine.\n        include_private (bool): whether to include items that begin with '_'\n            (True) or to exclude them (False). Defauls to False.\n\n    Returns:\n        dict[str, inspect.Signature]: dict of method signatures in 'item' (keys \n            are method names and values are method signatures).\n\n    \"\"\" \n    methods = name_methods(item, include_private = include_private)\n    signatures = [inspect.signature(getattr(item, m)) for m in methods]\n    return dict(zip(methods, signatures))\n</code></pre>"},{"location":"reference/miller/attributes/#miller.attributes.name_attributes","title":"<code>name_attributes(item, include_private=False)</code>","text":"<p>Returns attribute names of 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to examine.</p> required <code>include_private</code> <code>bool</code> <p>whether to include items that begin with '_' (True) or to exclude them (False). Defauls to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: names of attributes in 'item'.</p> Source code in <code>src/miller/attributes.py</code> <pre><code>def name_attributes(\n    item: Any, \n    include_private: bool = False) -&gt; list[str]:\n\"\"\"Returns attribute names of 'item'.\n\n    Args:\n        item (Any): item to examine.\n        include_private (bool): whether to include items that begin with '_'\n            (True) or to exclude them (False). Defauls to False.\n\n    Returns:\n        list[str]: names of attributes in 'item'.\n\n    \"\"\"\n    names = dir(item)\n    if not include_private:\n        names = camina.drop_privates(names)\n    return names\n</code></pre>"},{"location":"reference/miller/attributes/#miller.attributes.name_fields","title":"<code>name_fields(item, include_private=False)</code>","text":"<p>Returns whether 'attributes' exist in dataclass 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>dataclass | type[dataclasses.dataclass]</code> <p>dataclass or  dataclass instance to examine.</p> required <code>include_private</code> <code>bool</code> <p>whether to include items that begin with '_' (True) or to exclude them (False). Defauls to False.    </p> <code>False</code> <p>Raises:     TypeError: if 'item' is not a dataclass.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: names of fields in 'item'.</p> Source code in <code>src/miller/attributes.py</code> <pre><code>def name_fields(\n    item: dataclasses.dataclass | type[dataclasses.dataclass], \n    include_private: bool = False) -&gt; list[str]:\n\"\"\"Returns whether 'attributes' exist in dataclass 'item'.\n\n    Args:\n        item (dataclasses.dataclass | type[dataclasses.dataclass]): dataclass or \n            dataclass instance to examine.\n        include_private (bool): whether to include items that begin with '_'\n            (True) or to exclude them (False). Defauls to False.    \n    Raises:\n        TypeError: if 'item' is not a dataclass.\n\n    Returns:\n        list[str]: names of fields in 'item'.\n\n    \"\"\"\n    if dataclasses.identity.is_dataclass(item):\n        attributes = [f.name for f in dataclasses.fields(item)]\n        if not include_private:\n            attributes = camina.drop_privates(attributes)\n        return attributes\n    else:\n        raise TypeError('item must be a dataclass')\n</code></pre>"},{"location":"reference/miller/attributes/#miller.attributes.name_methods","title":"<code>name_methods(item, include_private=False)</code>","text":"<p>Returns method names of 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to examine.</p> required <code>include_private</code> <code>bool</code> <p>whether to include items that begin with '_' (True) or to exclude them (False). Defauls to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: names of methods in 'item'.</p> Source code in <code>src/miller/attributes.py</code> <pre><code>def name_methods(\n    item: Any, \n    include_private: bool = False) -&gt; list[str]:\n\"\"\"Returns method names of 'item'.\n\n    Args:\n        item (Any): item to examine.\n        include_private (bool): whether to include items that begin with '_'\n            (True) or to exclude them (False). Defauls to False.\n\n    Returns:\n        list[str]: names of methods in 'item'.\n\n    \"\"\"\n    methods = [\n        a for a in dir(item)\n        if is_method(item, attribute = a)]\n    if not include_private:\n        methods = camina.drop_privates(methods)\n    return methods\n</code></pre>"},{"location":"reference/miller/attributes/#miller.attributes.name_parameters","title":"<code>name_parameters(item)</code>","text":"<p>Returns list of parameters based on annotations of 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>type[Any]</code> <p>class to get parameters to.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: names of parameters in 'item'.</p> Source code in <code>src/miller/attributes.py</code> <pre><code>def name_parameters(item: type[Any]) -&gt; list[str]:\n\"\"\"Returns list of parameters based on annotations of 'item'.\n\n    Args:\n        item (type[Any]): class to get parameters to.\n\n    Returns:\n        list[str]: names of parameters in 'item'.\n\n    \"\"\"          \n    return list(item.__annotations__.keys())\n</code></pre>"},{"location":"reference/miller/attributes/#miller.attributes.name_properties","title":"<code>name_properties(item, include_private=False)</code>","text":"<p>Returns method names of 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to examine.</p> required <code>include_private</code> <code>bool</code> <p>whether to include items that begin with '_' (True) or to exclude them (False). Defauls to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: names of properties in 'item'.</p> Source code in <code>src/miller/attributes.py</code> <pre><code>def name_properties(\n    item: Any, \n    include_private: bool = False) -&gt; list[str]:\n\"\"\"Returns method names of 'item'.\n\n    Args:\n        item (Any): item to examine.\n        include_private (bool): whether to include items that begin with '_'\n            (True) or to exclude them (False). Defauls to False.\n\n    Returns:\n        list[str]: names of properties in 'item'.\n\n    \"\"\"\n    if not inspect.isclass(item):\n        item.__class__\n    properties = [\n        a for a in dir(item)\n        if is_property(item, attribute = a)]\n    if not include_private:\n        properties = camina.drop_privates(properties)\n    return properties\n</code></pre>"},{"location":"reference/miller/base/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> base","text":"<p>base: generic introspection functions Corey Rayburn Yung coreyrayburnyung@gmail.com Copyright 2020-2022, Corey Rayburn Yung License: Apache-2.0</p> <pre><code>Licensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre> <p>Contents:</p> <p>ToDo:</p>"},{"location":"reference/miller/base/#miller.base.has_elements","title":"<code>has_elements(item, attributes, checker, raise_error=None, match_all=None)</code>","text":"<p>Returns whether 'item' has 'elements' or an error.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>class or instance to examine.</p> required <code>attributes</code> <code>MutableSequence[str]</code> <p>names of attributes to check.</p> required <code>checker</code> <code>Callable[[Any, Any, bool], bool]</code> <p>function to call to  determine if an attribute in 'attributes' qualifies as the  appropriate type.</p> required <code>raise_error</code> <code>Optional[bool]</code> <p>whether to raise an error if any  'attributes' are not attributes of 'item' (True) or to simply  return False in such situations. Defaults to None, which means the  global 'miller.RAISE_ERRORS' setting will be used.</p> <code>None</code> <code>match_all</code> <code>Optional[bool]</code> <p>whether all items in 'attributes' must match (True) or any of the items must match (False). Defaults to None, which means the global 'miller.MATCH_ALL' will be used.</p> <code>None</code> <p>Raises:</p> Type Description <code>AttributeError</code> <p>if 'attributes' are not attributes of 'item' and  'raise_error' is True (or if it is None and the global setting is True).</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether some or all (depending on 'match_all') of 'attributes'  exist in 'item' and are the appropriate type.</p> Source code in <code>src/miller/base.py</code> <pre><code>def has_elements(\n    item: Any,\n    attributes: MutableSequence[str],\n    checker: Callable[[Any, Any, bool], bool],\n    raise_error: Optional[bool] = None,\n    match_all: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns whether 'item' has 'elements' or an error.\n\n    Args:\n        item (Any): class or instance to examine.\n        attributes (MutableSequence[str]): names of attributes to check.\n        checker (Callable[[Any, Any, bool], bool]): function to call to \n            determine if an attribute in 'attributes' qualifies as the \n            appropriate type.\n        raise_error (Optional[bool]): whether to raise an error if any \n            'attributes' are not attributes of 'item' (True) or to simply \n            return False in such situations. Defaults to None, which means the \n            global 'miller.RAISE_ERRORS' setting will be used.\n        match_all (Optional[bool]): whether all items in 'attributes' must match\n            (True) or any of the items must match (False). Defaults to None,\n            which means the global 'miller.MATCH_ALL' will be used.\n\n    Raises:\n        AttributeError: if 'attributes' are not attributes of 'item' and \n            'raise_error' is True (or if it is None and the global setting is\n            True).\n\n    Returns:\n        bool: whether some or all (depending on 'match_all') of 'attributes' \n            exist in 'item' and are the appropriate type.\n\n    \"\"\"\n    raise_error = configuration.RAISE_ERRORS if None else raise_error\n    match_all = configuration.MATCH_ALL if None else match_all \n    scope = all if match_all else any\n    kwargs = dict(raise_error = False)\n    value = scope(checker(item, a, **kwargs) for a in attributes)  \n    return report_has(\n        value = value,\n        raise_error = raise_error,\n        match_all = match_all,\n        item = item,\n        attributes = attributes)\n</code></pre>"},{"location":"reference/miller/base/#miller.base.is_kind","title":"<code>is_kind(item, checker, raise_error=None, kind=None)</code>","text":"<p>Returns whether 'item' is 'kind' or an error.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>class or instance to examine.</p> required <code>checker</code> <code>(Callable[[Any, Type[Any]], bool] | Callable[[Any], bool])</code> <p>function to call to determine if 'item' is the appropriate type.</p> required <code>raise_error</code> <code>Optional[bool]</code> <p>whether to raise an error if 'attribute'  is not an attribute of 'item' (True) or to simply return False in such situations. Defaults to None, which means the global  'miller.RAISE_ERRORS' setting will be used.</p> <code>None</code> <code>kind</code> <code>Type[Any]</code> <p>type to check if 'item' is.</p> <code>None</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>if 'item' is not the appropriate type and 'raise_error' is  True (or if it is None and the global setting is True).</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether 'item' is a 'kind'.</p> Source code in <code>src/miller/base.py</code> <pre><code>def is_kind(\n    item: Any,\n    checker: Callable[[Any, Type[Any]], bool] | Callable[[Any], bool],\n    raise_error: Optional[bool] = None,\n    kind: Optional[Type[Any] | str] = None) -&gt; bool:\n\"\"\"Returns whether 'item' is 'kind' or an error.\n\n    Args:\n        item (Any): class or instance to examine.\n        checker (Callable[[Any, Type[Any]], bool] | Callable[[Any], bool],): \n            function to call to determine if 'item' is the appropriate type.\n        raise_error (Optional[bool]): whether to raise an error if 'attribute' \n            is not an attribute of 'item' (True) or to simply return False in\n            such situations. Defaults to None, which means the global \n            'miller.RAISE_ERRORS' setting will be used.\n        kind (Type[Any]): type to check if 'item' is.\n\n    Raises:\n        TypeError: if 'item' is not the appropriate type and 'raise_error' is \n            True (or if it is None and the global setting is True).\n\n    Returns:\n        bool: whether 'item' is a 'kind'.\n\n    \"\"\"\n    raise_error = configuration.RAISE_ERRORS if None else raise_error\n    value = checker(item) if kind is None else checker(item, kind)  \n    return report_is(\n        value = value,\n        raise_error = raise_error,\n        item = item,\n        kind = kind) \n</code></pre>"},{"location":"reference/miller/base/#miller.base.is_kind_class","title":"<code>is_kind_class(item, checker, raise_error, kind)</code>","text":"<p>Returns whether 'item' is 'kind' or an error.</p> <p>Parameters:</p> Name Type Description Default <code>checker</code> <code>(Callable[[Any, Type[Any]], bool] | Callable[[Any], bool])</code> <p>function to call to determine if 'item' is the appropriate type.</p> required <code>raise_error</code> <code>Optional[bool]</code> <p>whether to raise an error if 'attribute'  is not an attribute of 'item' (True) or to simply return False in such situations. Defaults to None, which means the global  'miller.RAISE_ERRORS' setting will be used.</p> required <code>item</code> <code>Any</code> <p>class or instance to examine.</p> required <code>kind</code> <code>Type[Any]</code> <p>type to check if 'item' is.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if 'item' is not the appropriate type and 'raise_error' is  True (or if it is None and the global setting is True).</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether 'item' is a 'kind'.</p> Source code in <code>src/miller/base.py</code> <pre><code>def is_kind_class(\n    item: Any,\n    checker: Callable[[Any, Type[Any]], bool] | Callable[[Any], bool],\n    raise_error: bool,\n    kind: Type[Any]) -&gt; bool:\n\"\"\"Returns whether 'item' is 'kind' or an error.\n\n    Args:\n        checker (Callable[[Any, Type[Any]], bool] | Callable[[Any], bool],): \n            function to call to determine if 'item' is the appropriate type.\n        raise_error (Optional[bool]): whether to raise an error if 'attribute' \n            is not an attribute of 'item' (True) or to simply return False in\n            such situations. Defaults to None, which means the global \n            'miller.RAISE_ERRORS' setting will be used.\n        item (Any): class or instance to examine.\n        kind (Type[Any]): type to check if 'item' is.\n\n    Raises:\n        TypeError: if 'item' is not the appropriate type and 'raise_error' is \n            True (or if it is None and the global setting is True).\n\n    Returns:\n        bool: whether 'item' is a 'kind'.\n\n    \"\"\"\n    raise_error = configuration.RAISE_ERRORS if None else raise_error\n    value = checker(item) if kind is None else checker(item, kind)  \n    return report_is(\n        value = value,\n        raise_error = raise_error,\n        item = item,\n        kind = kind)\n</code></pre>"},{"location":"reference/miller/base/#miller.base.is_kind_container","title":"<code>is_kind_container(item, checker, raise_error=None, include_str=None, kind=None)</code>","text":"<p>Returns whether 'item' is 'kind' or an error.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>class or instance to examine.</p> required <code>checker</code> <code>(Callable[[Any, Type[Any]], bool] | Callable[[Any], bool])</code> <p>function to call to determine if 'item' is the appropriate type.</p> required <code>raise_error</code> <code>Optional[bool]</code> <p>whether to raise an error if 'attribute'  is not an attribute of 'item' (True) or to simply return False in such situations. Defaults to None, which means the global  'miller.RAISE_ERRORS' setting will be used.</p> <code>None</code> <code>kind</code> <code>Type[Any]</code> <p>type to check if 'item' is.</p> <code>None</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>if 'item' is not the appropriate type and 'raise_error' is  True (or if it is None and the global setting is True).</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether 'item' is a 'kind'.</p> Source code in <code>src/miller/base.py</code> <pre><code>def is_kind_container(\n    item: Any,\n    checker: Callable[[Any, Type[Any]], bool] | Callable[[Any], bool],\n    raise_error: Optional[bool] = None,\n    include_str: Optional[bool] = None,\n    kind: Optional[Type[Any] | str] = None) -&gt; bool:\n\"\"\"Returns whether 'item' is 'kind' or an error.\n\n    Args:\n        item (Any): class or instance to examine.\n        checker (Callable[[Any, Type[Any]], bool] | Callable[[Any], bool],): \n            function to call to determine if 'item' is the appropriate type.\n        raise_error (Optional[bool]): whether to raise an error if 'attribute' \n            is not an attribute of 'item' (True) or to simply return False in\n            such situations. Defaults to None, which means the global \n            'miller.RAISE_ERRORS' setting will be used.\n        kind (Type[Any]): type to check if 'item' is.\n\n    Raises:\n        TypeError: if 'item' is not the appropriate type and 'raise_error' is \n            True (or if it is None and the global setting is True).\n\n    Returns:\n        bool: whether 'item' is a 'kind'.\n\n    \"\"\"\n    raise_error = configuration.RAISE_ERRORS if None else raise_error\n    include_str = configuration.INCLUDE_STR if None else include_str\n    value = checker(item) if kind is None else checker(item, kind)  \n    if not include_str and isinstance(item, str):\n        value = False\n    return report_is(\n        value = value,\n        raise_error = raise_error,\n        item = item,\n        kind = kind) \n</code></pre>"},{"location":"reference/miller/base/#miller.base.list_elements","title":"<code>list_elements(checker, raise_error, match_all, item)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>checker</code> <code>Callable[[Any, Any, bool], bool]</code> <p>description</p> required <code>raise_error</code> <code>bool</code> <p>description</p> required <code>match_all</code> <code>bool</code> <p>description</p> required <code>item</code> <code>Any</code> <p>description</p> required <code>elements</code> <code>MutableSequence[Any]</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>MutableSequence[Any]</code> <p>description</p> Source code in <code>src/miller/base.py</code> <pre><code>def list_elements(\n    checker: Callable[[Any, Any, bool], bool],\n    raise_error: bool,\n    match_all: bool,\n    item: Any) -&gt; MutableSequence[Any]:\n\"\"\"_summary_\n\n    Args:\n        checker (Callable[[Any, Any, bool], bool]): _description_\n        raise_error (bool): _description_\n        match_all (bool): _description_\n        item (Any): _description_\n        elements (MutableSequence[Any]): _description_\n\n    Returns:\n        bool: _description_\n\n    \"\"\"\n    match_all = configuration.MATCH_ALL if None else match_all \n    scope = all if match_all else any\n    kwargs = dict(raise_error = False)\n    value = scope(checker(item, a, **kwargs) for a in elements)  \n    return report_map(\n        value = value,\n        raise_error = raise_error,\n        match_all = match_all,\n        item = item,\n        elements = elements)\n</code></pre>"},{"location":"reference/miller/base/#miller.base.map_elements","title":"<code>map_elements(item, mapper, checker=None, raise_error=None, include_private=None)</code>","text":"<p>summary</p> Source code in <code>src/miller/base.py</code> <pre><code>def map_elements(\n    item: Any,\n    mapper: Callable[[Any, Any, bool], bool],\n    checker: Optional[Callable[[Any, Type[Any]], bool] | \n                      Callable[[Any], bool]] = None,\n    raise_error: Optional[bool] = None,\n    include_private: Optional[bool] = None) -&gt; MutableMapping[str, Any]:\n\"\"\"_summary_\n\n    \"\"\"\n    raise_error = configuration.RAISE_ERRORS if None else raise_error\n    include_private = configuration.INCLUDE_PRIVATE if None else include_private \n    return report_map(\n        value = value,\n        raise_error = raise_error,\n        match_all = match_all,\n        item = item,\n        elements = elements)\n</code></pre>"},{"location":"reference/miller/base/#miller.base.name_elements","title":"<code>name_elements(checker, raise_error, match_all, item)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>checker</code> <code>Callable[[Any, Any, bool], bool]</code> <p>description</p> required <code>raise_error</code> <code>bool</code> <p>description</p> required <code>match_all</code> <code>bool</code> <p>description</p> required <code>item</code> <code>Any</code> <p>description</p> required <code>elements</code> <code>MutableSequence[Any]</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>MutableSequence[str]</code> <p>description</p> Source code in <code>src/miller/base.py</code> <pre><code>def name_elements(\n    checker: Callable[[Any, Any, bool], bool],\n    raise_error: bool,\n    match_all: bool,\n    item: Any) -&gt; MutableSequence[str]:\n\"\"\"_summary_\n\n    Args:\n        checker (Callable[[Any, Any, bool], bool]): _description_\n        raise_error (bool): _description_\n        match_all (bool): _description_\n        item (Any): _description_\n        elements (MutableSequence[Any]): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    match_all = configuration.MATCH_ALL if None else match_all \n    scope = all if match_all else any\n    kwargs = dict(raise_error = False)\n    value = scope(checker(item, a, **kwargs) for a in elements)  \n    return report_map(\n        value = value,\n        raise_error = raise_error,\n        match_all = match_all,\n        item = item,\n        elements = elements)    \n</code></pre>"},{"location":"reference/miller/base/#miller.base.report_has","title":"<code>report_has(value, raise_error, match_all, item, attributes)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bool</code> <p>description</p> required <code>raise_error</code> <code>bool</code> <p>description</p> required <code>match_all</code> <code>bool</code> <p>description</p> required <code>item</code> <code>Any</code> <p>description</p> required <code>elements</code> <code>MutableSequence[Any]</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>src/miller/base.py</code> <pre><code>def report_has(\n    value: bool,\n    raise_error: bool,\n    match_all: bool,\n    item: Any, \n    attributes: MutableSequence[Any]) -&gt; bool:\n\"\"\"_summary_\n\n    Args:\n        value (bool): _description_\n        raise_error (bool): _description_\n        match_all (bool): _description_\n        item (Any): _description_\n        elements (MutableSequence[Any]): _description_\n\n    Returns:\n        bool: _description_\n\n    \"\"\"\n    if not value and raise_error and match_all:\n        raise AttributeError(\n            f'At least one of {attributes} is not in {item}')\n    elif not value and raise_error:\n        raise AttributeError(\n            f'Some of {attributes} are not in {item}')\n    elif not value:\n        return configuration.DEFAULT_HAS\n    else:\n        return value\n</code></pre>"},{"location":"reference/miller/base/#miller.base.report_is","title":"<code>report_is(value, raise_error, item, kind)</code>","text":"<p>summary</p> <p>Args:</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>src/miller/base.py</code> <pre><code>def report_is(\n    value: bool,\n    raise_error: bool,\n    item: Any, \n    kind: Optional[Type[Any]]) -&gt; bool:\n\"\"\"_summary_\n\n    Args:\n\n\n    Returns:\n        bool: _description_\n\n    \"\"\"\n    if not value and raise_error and kind is None:\n        raise TypeError(f'{item} failed the type check')\n    elif not value and raise_error:\n        raise TypeError(f'{item} is not {kind} type')\n    elif not value:\n        return configuration.DEFAULT_IS\n    else:\n        return value\n</code></pre>"},{"location":"reference/miller/base/#miller.base.report_list","title":"<code>report_list(value, raise_error, match_all, item, elements)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bool</code> <p>description</p> required <code>raise_error</code> <code>bool</code> <p>description</p> required <code>match_all</code> <code>bool</code> <p>description</p> required <code>item</code> <code>Any</code> <p>description</p> required <code>elements</code> <code>MutableSequence[Any]</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>src/miller/base.py</code> <pre><code>def report_list(\n    value: MutableSequence[Any],\n    raise_error: bool,\n    match_all: bool,\n    item: Any, \n    elements: MutableSequence[Any]) -&gt; bool:\n\"\"\"_summary_\n\n    Args:\n        value (bool): _description_\n        raise_error (bool): _description_\n        match_all (bool): _description_\n        item (Any): _description_\n        elements (MutableSequence[Any]): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    if not value and raise_error and match_all:\n        raise AttributeError(\n            f'At least one of {elements} is not in {item}')\n    elif not value and raise_error:\n        raise AttributeError(\n            f'Some of {elements} are not in {item}')\n    elif not value:\n        return configuration.DEFAULT_LIST\n    else:\n        return value\n</code></pre>"},{"location":"reference/miller/base/#miller.base.report_map","title":"<code>report_map(value, raise_error, match_all, item, elements)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bool</code> <p>description</p> required <code>raise_error</code> <code>bool</code> <p>description</p> required <code>match_all</code> <code>bool</code> <p>description</p> required <code>item</code> <code>Any</code> <p>description</p> required <code>elements</code> <code>MutableSequence[Any]</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>src/miller/base.py</code> <pre><code>def report_map(\n    value: MutableMapping[Hashable, Any],\n    raise_error: bool,\n    match_all: bool,\n    item: Any, \n    elements: MutableSequence[Any]) -&gt; bool:\n\"\"\"_summary_\n\n    Args:\n        value (bool): _description_\n        raise_error (bool): _description_\n        match_all (bool): _description_\n        item (Any): _description_\n        elements (MutableSequence[Any]): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    if not value and raise_error and match_all:\n        raise AttributeError(\n            f'At least one of {elements} is not in {item}')\n    elif not value and raise_error:\n        raise AttributeError(\n            f'Some of {elements} are not in {item}')\n    elif not value:\n        return configuration.DEFAULT_MAP\n    else:\n        return value\n</code></pre>"},{"location":"reference/miller/base/#miller.base.report_name","title":"<code>report_name(value, raise_error, match_all, item, elements)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bool</code> <p>description</p> required <code>raise_error</code> <code>bool</code> <p>description</p> required <code>match_all</code> <code>bool</code> <p>description</p> required <code>item</code> <code>Any</code> <p>description</p> required <code>elements</code> <code>MutableSequence[Any]</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>src/miller/base.py</code> <pre><code>def report_name(\n    value: MutableSequence[str],\n    raise_error: bool,\n    match_all: bool,\n    item: Any, \n    elements: MutableSequence[Any]) -&gt; bool:\n\"\"\"_summary_\n\n    Args:\n        value (bool): _description_\n        raise_error (bool): _description_\n        match_all (bool): _description_\n        item (Any): _description_\n        elements (MutableSequence[Any]): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    if not value and raise_error and match_all:\n        raise AttributeError(\n            f'At least one of {elements} is not in {item}')\n    elif not value and raise_error:\n        raise AttributeError(\n            f'Some of {elements} are not in {item}')\n    elif not value:\n        return configuration.DEFAULT_NAME\n    else:\n        return value\n</code></pre>"},{"location":"reference/miller/configuration/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> configuration","text":"<p>configuration: global settings for miller Corey Rayburn Yung coreyrayburnyung@gmail.com Copyright 2020-2022, Corey Rayburn Yung License: Apache-2.0</p> <pre><code>Licensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre> <p>Contents:  </p> <p>ToDo:</p>"},{"location":"reference/miller/configuration/#miller.configuration.MISSING_VALUE","title":"<code>MISSING_VALUE</code>  <code>dataclass</code>","text":"<p>             Bases: <code>object</code></p> <p>Sentinel object for a missing data or parameter.</p> <p>This follows the same pattern as the '_MISSING_TYPE' class in the builtin dataclasses library.  https://github.com/python/cpython/blob/3.10/Lib/dataclasses.py#L182-L186</p> <p>Because None is sometimes a valid argument or data option, this class provides an alternative that does not create the confusion that a default of  None can sometimes lead to.</p>"},{"location":"reference/miller/containers/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> containers","text":"<p>containers: introspection tools for containers Corey Rayburn Yung coreyrayburnyung@gmail.com Copyright 2020-2022, Corey Rayburn Yung License: Apache-2.0</p> <pre><code>Licensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre> <p>Contents:</p> ToDo <p>Add support for Kinds once that system is complete.</p>"},{"location":"reference/miller/containers/#miller.containers.has_types","title":"<code>has_types(item, /, contents)</code>","text":"<p>Returns whether 'item' contains the type(s) in 'contents'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>object</code> <p>item to examine.</p> required <code>contents</code> <code>Type[Any] | tuple[Type[Any], ...]</code> <p>types to check for in  'item' contents.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if 'item' does not match any of the registered types.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether 'item' holds the types in 'contents'.</p> Source code in <code>src/miller/containers.py</code> <pre><code>@functools.singledispatch\ndef has_types(\n    item: object, /,\n    contents: Type[Any] | tuple[Type[Any], ...]) -&gt; bool:\n\"\"\"Returns whether 'item' contains the type(s) in 'contents'.\n\n    Args:\n        item (object): item to examine.\n        contents (Type[Any] | tuple[Type[Any], ...]): types to check for in \n            'item' contents.\n\n    Raises:\n        TypeError: if 'item' does not match any of the registered types.\n\n    Returns:\n        bool: whether 'item' holds the types in 'contents'.\n\n    \"\"\"\n    raise TypeError(f'item {item} is not supported by {__name__}')\n</code></pre>"},{"location":"reference/miller/containers/#miller.containers.has_types_container","title":"<code>has_types_container(item, /, contents)</code>","text":"<p>Returns whether container 'item' contains the type(s) in 'contents'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Container[Any]</code> <p>item to examine.</p> required <code>contents</code> <code>Type[Any] | tuple[Type[Any], ...]</code> <p>types to check for in  'item' contents.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether 'item' holds the types in 'contents'.</p> Source code in <code>src/miller/containers.py</code> <pre><code>@has_types.register(Container)       \ndef has_types_container(\n    item: Container[Any], /,\n    contents: Type[Any] | tuple[Type[Any], ...]) -&gt; bool:\n\"\"\"Returns whether container 'item' contains the type(s) in 'contents'.\n\n    Args:\n        item (Container[Any]): item to examine.\n        contents (Type[Any] | tuple[Type[Any], ...]): types to check for in \n            'item' contents.\n\n    Returns:\n        bool: whether 'item' holds the types in 'contents'.\n\n    \"\"\"\n    return all(isinstance(i, contents) for i in item)\n</code></pre>"},{"location":"reference/miller/containers/#miller.containers.has_types_dict","title":"<code>has_types_dict(item, /, contents)</code>","text":"<p>Returns whether dict-like 'item' contains the type(s) in 'contents'.</p> <p>In 'contents', the first item in the passed tuple should be the type(s) to check against the keys in 'item' and the second item in the passed tuple should be the type(s) to check against the values in 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Mapping[Hashable, Any]</code> <p>item to examine.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether 'item' holds the types in 'contents'.</p> Source code in <code>src/miller/containers.py</code> <pre><code>@has_types.register(Mapping)    \ndef has_types_dict(\n    item: Mapping[Hashable, Any], /, \n    contents: tuple[Type[Any] | tuple[Type[Any], ...],\n                    Type[Any] | tuple[Type[Any], ...]]) -&gt; bool:\n\"\"\"Returns whether dict-like 'item' contains the type(s) in 'contents'.\n\n    In 'contents', the first item in the passed tuple should be the type(s) to\n    check against the keys in 'item' and the second item in the passed tuple\n    should be the type(s) to check against the values in 'item'.\n\n    Args:\n        item (Mapping[Hashable, Any]): item to examine.\n        contents (tuple[Type[Any] | tuple[Type[Any], ...], Type[Any] | \n            tuple[Type[Any], ...]]): types to check for in 'item' contents.\n\n    Returns:\n        bool: whether 'item' holds the types in 'contents'.\n\n    \"\"\"\n    return (\n        has_types_container(item.keys(), contents = contents[0])\n        and has_types_container(item.values(), contents = contents[1]))\n</code></pre>"},{"location":"reference/miller/containers/#miller.containers.has_types_list","title":"<code>has_types_list(item, /, contents)</code>","text":"<p>Returns whether list-like 'item' contains the type(s) in 'contents'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>MutableSequence[Any]</code> <p>item to examine.</p> required <code>contents</code> <code>Type[Any] | tuple[Type[Any], ...]</code> <p>types to check for in  'item' contents.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether 'item' holds the types in 'contents'.</p> Source code in <code>src/miller/containers.py</code> <pre><code>@has_types.register(MutableSequence)   \ndef has_types_list(\n    item: MutableSequence[Any], /,\n    contents: Type[Any] | tuple[Type[Any], ...]) -&gt; bool:\n\"\"\"Returns whether list-like 'item' contains the type(s) in 'contents'.\n\n    Args:\n        item (MutableSequence[Any]): item to examine.\n        contents (Type[Any] | tuple[Type[Any], ...]): types to check for in \n            'item' contents.\n\n    Returns:\n        bool: whether 'item' holds the types in 'contents'.\n\n    \"\"\"\n    return has_types_container(item, contents = contents)\n</code></pre>"},{"location":"reference/miller/containers/#miller.containers.has_types_sequence","title":"<code>has_types_sequence(item, /, contents)</code>","text":"<p>Returns whether sequence 'item' contains the type(s) in 'contents'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Sequence[Any]</code> <p>item to examine.</p> required <code>contents</code> <code>tuple[Type[Any], ...]</code> <p>types to check for in 'item' contents.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether 'item' holds the types in 'contents'.</p> Source code in <code>src/miller/containers.py</code> <pre><code>@has_types.register(Sequence)   \ndef has_types_sequence(\n    item: Sequence[Any], /,\n    contents: tuple[Type[Any], ...]) -&gt; bool:\n\"\"\"Returns whether sequence 'item' contains the type(s) in 'contents'.\n\n    Args:\n        item (Sequence[Any]): item to examine.\n        contents (tuple[Type[Any], ...]): types to check for in 'item' contents.\n\n    Returns:\n        bool: whether 'item' holds the types in 'contents'.\n\n    \"\"\"\n    return all(isinstance(item[i], contents[i]) for i in enumerate(item))\n</code></pre>"},{"location":"reference/miller/containers/#miller.containers.has_types_set","title":"<code>has_types_set(item, /, contents)</code>","text":"<p>Returns whether set-like 'item' contains the type(s) in 'contents'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Set[Any]</code> <p>item to examine.</p> required <code>contents</code> <code>Type[Any] | tuple[Type[Any], ...]</code> <p>types to check for in  'item' contents.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether 'item' holds the types in 'contents'.</p> Source code in <code>src/miller/containers.py</code> <pre><code>@has_types.register(Set)   \ndef has_types_set(\n    item: Set[Any], /,\n    contents: Type[Any] | tuple[Type[Any], ...]) -&gt; bool:\n\"\"\"Returns whether set-like 'item' contains the type(s) in 'contents'.\n\n    Args:\n        item (Set[Any]): item to examine.\n        contents (Type[Any] | tuple[Type[Any], ...]): types to check for in \n            'item' contents.\n\n    Returns:\n        bool: whether 'item' holds the types in 'contents'.\n\n    \"\"\"\n    return has_types_container(item, contents = contents)\n</code></pre>"},{"location":"reference/miller/containers/#miller.containers.has_types_tuple","title":"<code>has_types_tuple(item, /, contents)</code>","text":"<p>Returns whether tuple 'item' contains the type(s) in 'contents'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>tuple[Any, ...]</code> <p>item to examine.</p> required <code>contents</code> <code>Type[Any] | tuple[Type[Any], ...]</code> <p>types to check for in  'item' contents.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether 'item' holds the types in 'contents'.</p> Source code in <code>src/miller/containers.py</code> <pre><code>@has_types.register(tuple)   \ndef has_types_tuple(\n    item: tuple[Any, ...], /,\n    contents: Type[Any] | tuple[Type[Any], ...]) -&gt; bool:\n\"\"\"Returns whether tuple 'item' contains the type(s) in 'contents'.\n\n    Args:\n        item (tuple[Any, ...]): item to examine.\n        contents (Type[Any] | tuple[Type[Any], ...]): types to check for in \n            'item' contents.\n\n    Returns:\n        bool: whether 'item' holds the types in 'contents'.\n\n    \"\"\"\n    if isinstance(contents, tuple) and len(item) == len(contents):\n        technique = has_types_sequence\n    else:\n        technique = has_types_container\n    return technique(item, contents = contents)\n</code></pre>"},{"location":"reference/miller/containers/#miller.containers.list_types","title":"<code>list_types(item)</code>","text":"<p>Returns types contained in 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>object</code> <p>item to examine.</p> required <p>Returns:</p> Type Description <code>Optional[tuple[Type[Any], ...] | tuple[tuple[Type[Any], ...], tuple[Type[Any], ...]]]</code> <p>Optional[Union[tuple[Type[Any], ...], tuple[tuple[Type[Any], ...],  tuple[Type[Any], ...]]]]:: returns the types of things contained  in 'item'. Returns None if 'item' is not a container.</p> Source code in <code>src/miller/containers.py</code> <pre><code>@functools.singledispatch\ndef list_types(item: object) -&gt; Optional[\n    tuple[Type[Any], ...] |\n    tuple[tuple[Type[Any], ...], tuple[Type[Any], ...]]]:\n\"\"\"Returns types contained in 'item'.\n\n    Args:\n        item (object): item to examine.\n\n    Returns:\n        Optional[Union[tuple[Type[Any], ...], tuple[tuple[Type[Any], ...], \n            tuple[Type[Any], ...]]]]:: returns the types of things contained \n            in 'item'. Returns None if 'item' is not a container.\n\n    \"\"\"\n    raise TypeError(f'item {item} is not supported by {__name__}')\n</code></pre>"},{"location":"reference/miller/containers/#miller.containers.list_types_dict","title":"<code>list_types_dict(item)</code>","text":"<p>Returns types contained in 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>object</code> <p>item to examine.</p> required <p>Returns:</p> Type Description <code>Optional[tuple[tuple[Type[Any], ...], tuple[Type[Any], ...]]]</code> <p>Optional[tuple[Type[Any], ...]]: returns the types of things contained  in 'item'. Returns None if 'item' is not a container.</p> Source code in <code>src/miller/containers.py</code> <pre><code>@list_types.register(Mapping)  \ndef list_types_dict(\n    item: Mapping[Hashable, Any]) -&gt; Optional[\n        tuple[tuple[Type[Any], ...], tuple[Type[Any], ...]]]:\n\"\"\"Returns types contained in 'item'.\n\n    Args:\n        item (object): item to examine.\n\n    Returns:\n        Optional[tuple[Type[Any], ...]]: returns the types of things contained \n            in 'item'. Returns None if 'item' is not a container.\n\n    \"\"\"\n    if isinstance(item, Mapping):\n        key_types = list_types_sequence(item.keys())\n        value_types = list_types_sequence(item.values())\n        return tuple(key_types, value_types)\n    else:\n        return None\n</code></pre>"},{"location":"reference/miller/containers/#miller.containers.list_types_list","title":"<code>list_types_list(item)</code>","text":"<p>Returns types contained in 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>list[Any]</code> <p>item to examine.</p> required <p>Returns:</p> Type Description <code>Optional[tuple[Type[Any], ...]]</code> <p>Optional[tuple[Type[Any], ...]]: returns the types of things contained  in 'item'. Returns None if 'item' is not a container.</p> Source code in <code>src/miller/containers.py</code> <pre><code>@list_types.register(MutableSequence)  \ndef list_types_list(item: list[Any]) -&gt; Optional[tuple[Type[Any], ...]]:\n\"\"\"Returns types contained in 'item'.\n\n    Args:\n        item (list[Any]): item to examine.\n\n    Returns:\n        Optional[tuple[Type[Any], ...]]: returns the types of things contained \n            in 'item'. Returns None if 'item' is not a container.\n\n    \"\"\"\n    if isinstance(item, list):\n        key_types = list_types_sequence(item.keys())\n        value_types = list_types_sequence(item.values())\n        return tuple(key_types, value_types)\n    else:\n        return None\n</code></pre>"},{"location":"reference/miller/containers/#miller.containers.list_types_sequence","title":"<code>list_types_sequence(item)</code>","text":"<p>Returns types contained in 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Sequence[Any]</code> <p>item to examine.</p> required <p>Returns:</p> Type Description <code>Optional[tuple[Type[Any], ...]]</code> <p>Optional[tuple[Type[Any], ...]]: returns the types of things contained  in 'item'. Returns None if 'item' is not a container.</p> Source code in <code>src/miller/containers.py</code> <pre><code>@list_types.register(Sequence)    \ndef list_types_sequence(item: Sequence[Any]) -&gt; Optional[tuple[Type[Any], ...]]:\n\"\"\"Returns types contained in 'item'.\n\n    Args:\n        item (Sequence[Any]): item to examine.\n\n    Returns:\n        Optional[tuple[Type[Any], ...]]: returns the types of things contained \n            in 'item'. Returns None if 'item' is not a container.\n\n    \"\"\"\n    if isinstance(item, Sequence):\n        all_types = []\n        for thing in item:\n            kind = type(thing)\n            if not kind in all_types:\n                all_types.append(kind)\n        return tuple(all_types)\n    else:\n        return None\n</code></pre>"},{"location":"reference/miller/disks/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> disks","text":"<p>disks: introspection tools for files and folders Corey Rayburn Yung coreyrayburnyung@gmail.com Copyright 2020-2022, Corey Rayburn Yung License: Apache-2.0</p> <pre><code>Licensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre> Contents <p>has_files has_folders has_modules has_paths list_files list_folders list_modules list_paths map_files map_folders map_modules map_paths name_files name_folders name_modules name_paths   </p> <p>ToDo:</p>"},{"location":"reference/miller/disks/#miller.disks.has_files","title":"<code>has_files(item, elements, recursive=None)</code>","text":"<p>Returns whether all 'elements' are in 'item' and are files.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str | Path</code> <p>path of folder to examine.</p> required <code>elements</code> <code>list[str | Path]</code> <p>list of paths to test whether they  are in 'item'.</p> required <code>recursive</code> <code>Optional[bool]</code> <p>whether to include subfolders. Defaults to  None. If 'recursive' is None, 'miller.RECURSIVE' is used.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether all 'elements' are in 'item' and are files.</p> Source code in <code>src/miller/disks.py</code> <pre><code>def has_files(\n    item: str | pathlib.Path,\n    elements: list[str | pathlib.Path],\n    recursive: Optional[bool] = None) -&gt; bool:  \n\"\"\"Returns whether all 'elements' are in 'item' and are files.\n\n    Args:\n        item (str | pathlib.Path): path of folder to examine.\n        elements (list[str | pathlib.Path]): list of paths to test whether they \n            are in 'item'.\n        recursive (Optional[bool]): whether to include subfolders. Defaults to \n            None. If 'recursive' is None, 'miller.RECURSIVE' is used.\n\n    Returns:\n        bool: whether all 'elements' are in 'item' and are files.\n\n    \"\"\" \n    return (\n        has_paths(item, elements = elements, recursive = recursive)\n        and all(identity.is_file(path) for path in item))\n</code></pre>"},{"location":"reference/miller/disks/#miller.disks.has_folders","title":"<code>has_folders(item, elements, recursive=None)</code>","text":"<p>Returns whether all 'elements' are in 'item' and are folders.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str | Path</code> <p>path of folder to examine.</p> required <code>elements</code> <code>list[str | Path]</code> <p>list of paths to test whether they  are in 'item'.</p> required <code>recursive</code> <code>Optional[bool]</code> <p>whether to include subfolders. Defaults to  None. If 'recursive' is None, 'miller.RECURSIVE' is used.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether all 'elements' are in 'item' and are folders.</p> Source code in <code>src/miller/disks.py</code> <pre><code>def has_folders(\n    item: str | pathlib.Path,\n    elements: list[str | pathlib.Path],\n    recursive: Optional[bool] = None) -&gt; bool:  \n\"\"\"Returns whether all 'elements' are in 'item' and are folders.\n\n    Args:\n        item (str | pathlib.Path): path of folder to examine.\n        elements (list[str | pathlib.Path]): list of paths to test whether they \n            are in 'item'.\n        recursive (Optional[bool]): whether to include subfolders. Defaults to \n            None. If 'recursive' is None, 'miller.RECURSIVE' is used.\n\n    Returns:\n        bool: whether all 'elements' are in 'item' and are folders.\n\n    \"\"\" \n    return (\n        has_paths(item, elements = elements, recursive = recursive)\n        and all(identity.is_folder(path) for path in item))\n</code></pre>"},{"location":"reference/miller/disks/#miller.disks.has_modules","title":"<code>has_modules(item, elements, recursive=None)</code>","text":"<p>Returns whether all 'elements' are in 'item' and are modules.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str | Path</code> <p>path of folder to examine.</p> required <code>elements</code> <code>list[str | Path]</code> <p>list of paths to test whether they  are in 'item'.</p> required <code>recursive</code> <code>Optional[bool]</code> <p>whether to include subfolders. Defaults to  None. If 'recursive' is None, 'miller.RECURSIVE' is used.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether all 'elements' are in 'item' and are modules.</p> Source code in <code>src/miller/disks.py</code> <pre><code>def has_modules(\n    item: str | pathlib.Path,\n    elements: list[str | pathlib.Path],\n    recursive: Optional[bool] = None) -&gt; bool:  \n\"\"\"Returns whether all 'elements' are in 'item' and are modules.\n\n    Args:\n        item (str | pathlib.Path): path of folder to examine.\n        elements (list[str | pathlib.Path]): list of paths to test whether they \n            are in 'item'.\n        recursive (Optional[bool]): whether to include subfolders. Defaults to \n            None. If 'recursive' is None, 'miller.RECURSIVE' is used.\n\n    Returns:\n        bool: whether all 'elements' are in 'item' and are modules.\n\n    \"\"\" \n    return (\n        has_paths(item, elements = elements, recursive = recursive)\n        and all(identity.is_module(path) for path in item))\n</code></pre>"},{"location":"reference/miller/disks/#miller.disks.has_paths","title":"<code>has_paths(item, elements, recursive=None)</code>","text":"<p>Returns whether all 'elements' are in 'item' and are paths.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str | Path</code> <p>path of folder to examine.</p> required <code>elements</code> <code>list[str | Path]</code> <p>list of paths to test whether they  are in 'item'.</p> required <code>recursive</code> <code>Optional[bool]</code> <p>whether to include subfolders. Defaults to  None. If 'recursive' is None, 'miller.RECURSIVE' is used.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether all 'elements' are in 'item' and are paths.</p> Source code in <code>src/miller/disks.py</code> <pre><code>def has_paths(\n    item: str | pathlib.Path,\n    elements: list[str | pathlib.Path],\n    recursive: Optional[bool] = None) -&gt; bool:  \n\"\"\"Returns whether all 'elements' are in 'item' and are paths.\n\n    Args:\n        item (str | pathlib.Path): path of folder to examine.\n        elements (list[str | pathlib.Path]): list of paths to test whether they \n            are in 'item'.\n        recursive (Optional[bool]): whether to include subfolders. Defaults to \n            None. If 'recursive' is None, 'miller.RECURSIVE' is used.\n\n    Returns:\n        bool: whether all 'elements' are in 'item' and are paths.\n\n    \"\"\" \n    paths = list_paths(item, recursive = recursive)\n    elements = [camina.pahlibify(p) for p in elements]\n    return all(elements in paths) and all(identity.is_path(path) for path in item)\n</code></pre>"},{"location":"reference/miller/disks/#miller.disks.list_files","title":"<code>list_files(item, recursive=None, suffix='*')</code>","text":"<p>Returns list of non-python module file paths in 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str | Path</code> <p>path of folder to examine. </p> required <code>recursive</code> <code>Optional[bool]</code> <p>whether to include subfolders. Defaults to  None. If 'recursive' is None, 'miller.RECURSIVE' is used.</p> <code>None</code> <code>suffix</code> <code>Optional[str]</code> <p>file suffix to match. Defaults to '*' (all  suffixes).</p> <code>'*'</code> <p>Returns:</p> Type Description <code>list[pathlib.Path]</code> <p>list[pathlib.Path]: a list of file paths in 'item'.</p> Source code in <code>src/miller/disks.py</code> <pre><code>def list_files(\n    item: str | pathlib.Path, \n    recursive: Optional[bool] = None,\n    suffix: Optional[str] = '*') -&gt; list[pathlib.Path]:  \n\"\"\"Returns list of non-python module file paths in 'item'.\n\n    Args:\n        item (str | pathlib.Path): path of folder to examine. \n        recursive (Optional[bool]): whether to include subfolders. Defaults to \n            None. If 'recursive' is None, 'miller.RECURSIVE' is used.\n        suffix (Optional[str]): file suffix to match. Defaults to '*' (all \n            suffixes).\n\n    Returns:\n        list[pathlib.Path]: a list of file paths in 'item'.\n\n    \"\"\"\n    if recursive is None:\n        recursive = configuration.RECURSIVE   \n    paths = list_paths(item, recursive = recursive, suffix = suffix)\n    return [p for p in paths if identity.is_file(item = p)]\n</code></pre>"},{"location":"reference/miller/disks/#miller.disks.list_folders","title":"<code>list_folders(item, recursive=None)</code>","text":"<p>Returns list of folder paths in 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str | Path</code> <p>path of folder to examine.</p> required <code>recursive</code> <code>bool</code> <p>whether to include subfolders. Defaults to None. If 'recursive' is None, 'miller.RECURSIVE' is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[pathlib.Path]</code> <p>list[pathlib.Path]: a list of folder paths in 'item'.</p> Source code in <code>src/miller/disks.py</code> <pre><code>def list_folders(\n    item: str | pathlib.Path,\n    recursive: Optional[bool] = None) -&gt; list[pathlib.Path]:  \n\"\"\"Returns list of folder paths in 'item'.\n\n    Args:\n        item (str | pathlib.Path): path of folder to examine.\n        recursive (bool): whether to include subfolders. Defaults to None. If\n            'recursive' is None, 'miller.RECURSIVE' is used.\n\n    Returns:\n        list[pathlib.Path]: a list of folder paths in 'item'.\n\n    \"\"\"\n    if recursive is None:\n        recursive = configuration.RECURSIVE   \n    paths = list_paths(item, recursive = recursive)\n    return [p for p in paths if identity.is_folder(item = p)]\n</code></pre>"},{"location":"reference/miller/disks/#miller.disks.list_modules","title":"<code>list_modules(item, recursive=None, import_modules=False)</code>","text":"<p>Returns list of python module paths in 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str | Path</code> <p>path of folder to examine.</p> required <code>recursive</code> <code>bool</code> <p>whether to include subfolders. Defaults to None. If 'recursive' is None, 'miller.RECURSIVE' is used.</p> <code>None</code> <code>import_modules</code> <code>Optional[bool]</code> <p>whether the values in the returned dict should be imported modules (True) or file paths to modules (False).</p> <code>False</code> <p>Returns:</p> Type Description <code>list[Path | ModuleType]</code> <p>list[pathlib.Path |types.ModuleType]: a list of python module paths in  'item' or imported modules if 'import_modules' is True.</p> Source code in <code>src/miller/disks.py</code> <pre><code>def list_modules(\n    item: str | pathlib.Path,\n    recursive: Optional[bool] = None,\n    import_modules: Optional[bool] = False) -&gt; (\n        list[pathlib.Path |types.ModuleType]):  \n\"\"\"Returns list of python module paths in 'item'.\n\n    Args:\n        item (str | pathlib.Path): path of folder to examine.\n        recursive (bool): whether to include subfolders. Defaults to None. If\n            'recursive' is None, 'miller.RECURSIVE' is used.\n        import_modules (Optional[bool]): whether the values in the returned dict\n            should be imported modules (True) or file paths to modules (False).\n\n    Returns:\n        list[pathlib.Path |types.ModuleType]: a list of python module paths in \n            'item' or imported modules if 'import_modules' is True.\n\n    \"\"\"\n    if recursive is None:\n        recursive = configuration.RECURSIVE   \n    paths = list_paths(item, recursive = recursive)\n    modules = [p for p in paths if identity.is_module(item = p)]\n    if import_modules:\n        modules = [nagata.from_file_path(path = p) for p in modules]\n    return modules\n</code></pre>"},{"location":"reference/miller/disks/#miller.disks.list_paths","title":"<code>list_paths(item, recursive=None, suffix='*')</code>","text":"<p>Returns list of all paths in 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str | Path</code> <p>path of folder to examine. </p> required <code>recursive</code> <code>Optional[bool]</code> <p>whether to include subfolders. Defaults to  None. If 'recursive' is None, 'miller.RECURSIVE' is used.</p> <code>None</code> <code>suffix</code> <code>Optional[str]</code> <p>file suffix to match. Defaults to '*' (all  suffixes).</p> <code>'*'</code> <p>Returns:</p> Type Description <code>list[pathlib.Path]</code> <p>list[pathlib.Path]: a list of all paths in 'item'.</p> Source code in <code>src/miller/disks.py</code> <pre><code>def list_paths(\n    item: str | pathlib.Path, \n    recursive: Optional[bool] = None,\n    suffix: Optional[str] = '*') -&gt; list[pathlib.Path]:  \n\"\"\"Returns list of all paths in 'item'.\n\n    Args:\n        item (str | pathlib.Path): path of folder to examine. \n        recursive (Optional[bool]): whether to include subfolders. Defaults to \n            None. If 'recursive' is None, 'miller.RECURSIVE' is used.\n        suffix (Optional[str]): file suffix to match. Defaults to '*' (all \n            suffixes).\n\n    Returns:\n        list[pathlib.Path]: a list of all paths in 'item'.\n\n    \"\"\"\n    if recursive is None:\n        recursive = configuration.RECURSIVE   \n    item = camina.pathlibify(item) \n    if recursive:\n        return list(item.rglob(f'*.{suffix}'))\n    else:\n        return list(item.glob(f'*.{suffix}'))\n</code></pre>"},{"location":"reference/miller/disks/#miller.disks.map_files","title":"<code>map_files(item, recursive=None)</code>","text":"<p>Returns dict of python file names and file paths in 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str | Path</code> <p>path of folder to examine.</p> required <code>recursive</code> <code>Optional[bool]</code> <p>whether to include subfolders. Defaults to  None. If 'recursive' is None, 'miller.RECURSIVE' is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Path]</code> <p>dict[str, pathlib.Path]: dict with keys being file names and values being file paths.</p> Source code in <code>src/miller/disks.py</code> <pre><code>def map_files(\n    item: str | pathlib.Path,\n    recursive: Optional[bool] = None) -&gt; dict[str, pathlib.Path]:  \n\"\"\"Returns dict of python file names and file paths in 'item'.\n\n    Args:\n        item (str | pathlib.Path): path of folder to examine.\n        recursive (Optional[bool]): whether to include subfolders. Defaults to \n            None. If 'recursive' is None, 'miller.RECURSIVE' is used.\n\n    Returns:\n        dict[str, pathlib.Path]: dict with keys being file names and values\n            being file paths. \n\n    \"\"\"\n    if recursive is None:\n        recursive = configuration.RECURSIVE   \n    kwargs = dict(item = item, recursive = recursive)\n    names = name_files(**kwargs)\n    files = list_files(**kwargs)\n    return dict(zip(names, files))\n</code></pre>"},{"location":"reference/miller/disks/#miller.disks.map_folders","title":"<code>map_folders(item, recursive=None)</code>","text":"<p>Returns dict of python folder names and folder paths in 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str | Path</code> <p>path of folder to examine.</p> required <code>recursive</code> <code>Optional[bool]</code> <p>whether to include subfolders. Defaults to  None. If 'recursive' is None, 'miller.RECURSIVE' is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Path]</code> <p>dict[str, pathlib.Path]: dict with keys being folder names and values  being folder paths.</p> Source code in <code>src/miller/disks.py</code> <pre><code>def map_folders(\n    item: str | pathlib.Path,\n    recursive: Optional[bool] = None) -&gt; dict[str, pathlib.Path]:  \n\"\"\"Returns dict of python folder names and folder paths in 'item'.\n\n    Args:\n        item (str | pathlib.Path): path of folder to examine.\n        recursive (Optional[bool]): whether to include subfolders. Defaults to \n            None. If 'recursive' is None, 'miller.RECURSIVE' is used.\n\n    Returns:\n        dict[str, pathlib.Path]: dict with keys being folder names and values \n            being folder paths. \n\n    \"\"\"\n    if recursive is None:\n        recursive = configuration.RECURSIVE   \n    kwargs = dict(item = item, recursive = recursive)\n    names = name_folders(**kwargs)\n    folders = list_folders(**kwargs)\n    return dict(zip(names, folders))\n</code></pre>"},{"location":"reference/miller/disks/#miller.disks.map_modules","title":"<code>map_modules(item, recursive=None, import_modules=False)</code>","text":"<p>Returns dict of python module names and modules in 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str | Path</code> <p>path of folder to examine.</p> required <code>recursive</code> <code>Optional[bool]</code> <p>whether to include subfolders. Defaults to  None. If 'recursive' is None, 'miller.RECURSIVE' is used.</p> <code>None</code> <code>import_modules</code> <code>Optional[bool]</code> <p>whether the values in the returned dict should be imported modules (True) or file paths to modules (False).</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, ModuleType] | dict[str, Path]</code> <p>dict[str, types.ModuleType] | dict[str, pathlib.Path]: dict with str key  names of python modules and values as the paths to corresponding  modules or the imported modules (if 'import_modules' is True).</p> Source code in <code>src/miller/disks.py</code> <pre><code>def map_modules(\n    item: str | pathlib.Path,\n    recursive: Optional[bool] = None,\n    import_modules: Optional[bool] = False) -&gt; (\n        dict[str, types.ModuleType] | dict[str, pathlib.Path]):  \n\"\"\"Returns dict of python module names and modules in 'item'.\n\n    Args:\n        item (str | pathlib.Path): path of folder to examine.\n        recursive (Optional[bool]): whether to include subfolders. Defaults to \n            None. If 'recursive' is None, 'miller.RECURSIVE' is used.\n        import_modules (Optional[bool]): whether the values in the returned dict\n            should be imported modules (True) or file paths to modules (False).\n\n    Returns:\n        dict[str, types.ModuleType] | dict[str, pathlib.Path]: dict with str key \n            names of python modules and values as the paths to corresponding \n            modules or the imported modules (if 'import_modules' is True).\n\n    \"\"\"\n    if recursive is None:\n        recursive = configuration.RECURSIVE   \n    kwargs = dict(item = item, recursive = recursive)\n    names = name_modules(**kwargs)\n    modules = list_modules(**kwargs, import_modules = import_modules)\n    return dict(zip(names, modules))\n</code></pre>"},{"location":"reference/miller/disks/#miller.disks.map_paths","title":"<code>map_paths(item, recursive=None)</code>","text":"<p>Returns dict of python path names and paths in 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str | Path</code> <p>path of folder to examine.</p> required <code>recursive</code> <code>Optional[bool]</code> <p>whether to include subfolders. Defaults to  None. If 'recursive' is None, 'miller.RECURSIVE' is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Path]</code> <p>dict[str, pathlib.Path]: dict with keys being paht names and values being paths.</p> Source code in <code>src/miller/disks.py</code> <pre><code>def map_paths(\n    item: str | pathlib.Path,\n    recursive: Optional[bool] = None) -&gt; dict[str, pathlib.Path]:  \n\"\"\"Returns dict of python path names and paths in 'item'.\n\n    Args:\n        item (str | pathlib.Path): path of folder to examine.\n        recursive (Optional[bool]): whether to include subfolders. Defaults to \n            None. If 'recursive' is None, 'miller.RECURSIVE' is used.\n\n    Returns:\n        dict[str, pathlib.Path]: dict with keys being paht names and values\n            being paths. \n\n    \"\"\"\n    if recursive is None:\n        recursive = configuration.RECURSIVE   \n    kwargs = dict(item = item, recursive = recursive)\n    names = name_paths(**kwargs)\n    paths = list_paths(**kwargs)\n    return dict(zip(names, paths))\n</code></pre>"},{"location":"reference/miller/disks/#miller.disks.name_files","title":"<code>name_files(item, recursive=None)</code>","text":"<p>Returns list of names of file paths in 'item'.</p> <p>The 'stem' property of 'pathlib.Path' is used for the names.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str | Path</code> <p>path of folder to examine.</p> required <code>recursive</code> <code>bool</code> <p>whether to include subfolders. Defaults to None. If 'recursive' is None, 'miller.RECURSIVE' is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: a list of names of file paths in 'item'.</p> Source code in <code>src/miller/disks.py</code> <pre><code>def name_files(\n    item: str | pathlib.Path,\n    recursive: Optional[bool] = None) -&gt; list[str]:  \n\"\"\"Returns list of names of file paths in 'item'.\n\n    The 'stem' property of 'pathlib.Path' is used for the names.\n\n    Args:\n        item (str | pathlib.Path): path of folder to examine.\n        recursive (bool): whether to include subfolders. Defaults to None. If\n            'recursive' is None, 'miller.RECURSIVE' is used.\n\n    Returns:\n        list[str]: a list of names of file paths in 'item'.\n\n    \"\"\"\n    if recursive is None:\n        recursive = configuration.RECURSIVE   \n    item = camina.pathlibify(item)\n    kwargs = dict(item = item, recursive = recursive)\n    return [p.stem for p in list_files(**kwargs)]\n</code></pre>"},{"location":"reference/miller/disks/#miller.disks.name_folders","title":"<code>name_folders(item, recursive=None)</code>","text":"<p>Returns list of names of folder paths in 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str | Path</code> <p>path of folder to examine.</p> required <code>recursive</code> <code>bool</code> <p>whether to include subfolders. Defaults to None. If 'recursive' is None, 'miller.RECURSIVE' is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: a list of folder paths in 'item'.</p> Source code in <code>src/miller/disks.py</code> <pre><code>def name_folders(\n    item: str | pathlib.Path,\n    recursive: Optional[bool] = None) -&gt; list[str]:  \n\"\"\"Returns list of names of folder paths in 'item'.\n\n    Args:\n        item (str | pathlib.Path): path of folder to examine.\n        recursive (bool): whether to include subfolders. Defaults to None. If\n            'recursive' is None, 'miller.RECURSIVE' is used.\n\n    Returns:\n        list[str]: a list of folder paths in 'item'.\n\n    \"\"\"\n    if recursive is None:\n        recursive = configuration.RECURSIVE   \n    item = camina.pathlibify(item)\n    kwargs = dict(item = item, recursive = recursive)\n    return [p.name for p in list_folders(**kwargs)]\n</code></pre>"},{"location":"reference/miller/disks/#miller.disks.name_modules","title":"<code>name_modules(item, recursive=None)</code>","text":"<p>Returns list of names of paths to python modules in 'item'.</p> <p>The 'stem' property of 'pathlib.Path' is used for the names.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str | Path</code> <p>path of folder to examine.</p> required <code>recursive</code> <code>bool</code> <p>whether to include subfolders. Defaults to None. If 'recursive' is None, 'miller.RECURSIVE' is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: a list of names of paths to python modules in 'item'.</p> Source code in <code>src/miller/disks.py</code> <pre><code>def name_modules(\n    item: str | pathlib.Path,\n    recursive: Optional[bool] = None) -&gt; list[str]:  \n\"\"\"Returns list of names of paths to python modules in 'item'.\n\n    The 'stem' property of 'pathlib.Path' is used for the names.\n\n    Args:\n        item (str | pathlib.Path): path of folder to examine.\n        recursive (bool): whether to include subfolders. Defaults to None. If\n            'recursive' is None, 'miller.RECURSIVE' is used.\n\n    Returns:\n        list[str]: a list of names of paths to python modules in 'item'.\n\n    \"\"\"\n    if recursive is None:\n        recursive = configuration.RECURSIVE   \n    item = camina.pathlibify(item)\n    kwargs = dict(item = item, recursive = recursive)\n    return [p.stem for p in list_modules(**kwargs)]\n</code></pre>"},{"location":"reference/miller/disks/#miller.disks.name_paths","title":"<code>name_paths(item, recursive=None)</code>","text":"<p>Returns list of names of paths in 'item'.</p> <p>For folders, the 'name' property of 'pathlib.Path' is used. For files, the 'stem' property is.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str | Path</code> <p>path of folder to examine.</p> required <code>recursive</code> <code>bool</code> <p>whether to include subfolders. Defaults to None. If 'recursive' is None, 'miller.RECURSIVE' is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: a list of names of paths in 'item'.</p> Source code in <code>src/miller/disks.py</code> <pre><code>def name_paths(\n    item: str | pathlib.Path,\n    recursive: Optional[bool] = None) -&gt; list[str]:  \n\"\"\"Returns list of names of paths in 'item'.\n\n    For folders, the 'name' property of 'pathlib.Path' is used. For files, the\n    'stem' property is.\n\n    Args:\n        item (str | pathlib.Path): path of folder to examine.\n        recursive (bool): whether to include subfolders. Defaults to None. If\n            'recursive' is None, 'miller.RECURSIVE' is used.\n\n    Returns:\n        list[str]: a list of names of paths in 'item'.\n\n    \"\"\"\n    if recursive is None:\n        recursive = configuration.RECURSIVE   \n    kwargs = dict(item = item, recursive = recursive)\n    return name_files(**kwargs) + name_folders(**kwargs)\n</code></pre>"},{"location":"reference/miller/examiners/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> examiners","text":"<p>examiners: wrapper classes for object-oriented introspection Corey Rayburn Yung coreyrayburnyung@gmail.com Copyright 2020-2022, Corey Rayburn Yung License: Apache-2.0</p> <pre><code>Licensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre> Contents <p>Inspector (object): Base class factory for inspecting an arbitrary object.     When instanced, it will return an instance of the appropriate subclass     based on passed 'item'. Inspector and its subclasses have properties     describing the wrapped 'item' that are appropriate to the type of      'item'. ClassInspector (Inspector): inspector for classes. InstanceInspector (Inspector): inspector for class instances (objects). ModuleInspector (Inspector): inspector for modules. PackageInspector (Inspector): inspector for packages (file folders).</p> <p>ToDo:</p>"},{"location":"reference/miller/examiners/#miller.examiners.ClassInspector","title":"<code>ClassInspector</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Inspector</code></p> <p>Inspector for accessing class information from 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Type[Any]</code> <p>class to examine.</p> required <code>include_private</code> <code>bool</code> <p>whether to include items that begin with '_' (True) or to exclude them (False). Defauls to True.</p> <code>True</code>"},{"location":"reference/miller/examiners/#miller.examiners.ClassInspector.annotations","title":"<code>annotations: dict[str, Type[Any]]</code>  <code>property</code>","text":"<p>dict of parameters and annotated type hints in 'item'.</p> <p>Returns:</p> Type Description <code>dict[str, Type[Any]]</code> <p>dict[str, Type[Any]]: keys are parameter/attribute names and values are type hints.</p>"},{"location":"reference/miller/examiners/#miller.examiners.ClassInspector.attributes","title":"<code>attributes: list[str]</code>  <code>property</code>","text":"<p>Attribute names in 'item'.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: names of attributes.</p>"},{"location":"reference/miller/examiners/#miller.examiners.ClassInspector.include_private","title":"<code>include_private: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Properties</p>"},{"location":"reference/miller/examiners/#miller.examiners.ClassInspector.methods","title":"<code>methods: dict[str, types.MethodType]</code>  <code>property</code>","text":"<p>dict of method names and methods in 'item'.</p> <p>Returns:</p> Type Description <code>dict[str, MethodType]</code> <p>dict[str, types.MethodType]: keys are method names and values are  methods.</p>"},{"location":"reference/miller/examiners/#miller.examiners.ClassInspector.parameters","title":"<code>parameters: list[str]</code>  <code>property</code>","text":"<p>Names of parameters from a dataclass: 'item'.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: names of parameters for a dataclass.</p>"},{"location":"reference/miller/examiners/#miller.examiners.ClassInspector.properties","title":"<code>properties: list[str]</code>  <code>property</code>","text":"<p>Property names in 'item'.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: names of properties.</p>"},{"location":"reference/miller/examiners/#miller.examiners.ClassInspector.signatures","title":"<code>signatures: dict[str, inspect.Signature]</code>  <code>property</code>","text":"<p>dict of method names and signatures in 'item'.</p> <p>Returns:</p> Type Description <code>dict[str, Signature]</code> <p>dict[str, inspect.Signature]: keys are method names and values are  signatures for those methods.</p>"},{"location":"reference/miller/examiners/#miller.examiners.ClassInspector.variables","title":"<code>variables: list[str]</code>  <code>property</code>","text":"<p>Variable names in 'item'.</p> <p>'variables' are all attributes that are neither methods nor properties.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: names of variables in 'item'.</p>"},{"location":"reference/miller/examiners/#miller.examiners.Inspector","title":"<code>Inspector</code>  <code>dataclass</code>","text":"<p>             Bases: <code>object</code></p> <p>Inspector factory which returns the appropraite Inspector subclass.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>unknown item to examine.</p> required"},{"location":"reference/miller/examiners/#miller.examiners.Inspector.attributes","title":"<code>attributes: dict[str, Any]</code>  <code>property</code>","text":"<p>dict of attribute names and values in 'item'.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: keys are attribute names and values are attribute  values.</p>"},{"location":"reference/miller/examiners/#miller.examiners.Inspector.contains","title":"<code>contains: Optional[Union[tuple[Type[Any], ...], tuple[tuple[Type[Any], ...], tuple[Type[Any], ...]]]]</code>  <code>property</code>","text":"<p>Types that 'item' contains.</p> <p>Returns:</p> Type Description <code>Optional[Union[tuple[Type[Any], ...], tuple[tuple[Type[Any], ...], tuple[Type[Any], ...]]]]</code> <p>Optional[Union[tuple[Type[Any], ...], tuple[tuple[Type[Any], ...],  tuple[Type[Any], ...]]]]:: returns the types of things contained  in 'item'. Returns None if 'item' is not a container.</p>"},{"location":"reference/miller/examiners/#miller.examiners.Inspector.item","title":"<code>item: Any</code>  <code>instance-attribute</code>","text":"<p>Initialization Methods</p>"},{"location":"reference/miller/examiners/#miller.examiners.Inspector.name","title":"<code>name: Optional[str]</code>  <code>property</code>","text":"<p>str name of 'item'.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>Optional[str]</code> <p>inferred name of the stored 'item'.</p>"},{"location":"reference/miller/examiners/#miller.examiners.Inspector.type","title":"<code>type: Type[Any]</code>  <code>property</code>","text":"<p>Data type of 'item'.</p> <p>Returns:</p> Type Description <code>Type[Any]</code> <p>Type[Any]: type of the stored 'item'.</p>"},{"location":"reference/miller/examiners/#miller.examiners.Inspector.variables","title":"<code>variables: dict[str, Any]</code>  <code>property</code>","text":"<p>dict of variable names and variable values in 'item'.</p> <p>'variables' are all attributes that are neither methods nor properties.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: keys are variable names and values are variable  values.</p>"},{"location":"reference/miller/examiners/#miller.examiners.InstanceInspector","title":"<code>InstanceInspector</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Inspector</code></p> <p>Inspector for accessing instance information from 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Type[Any]</code> <p>instance to examine.</p> required <code>include_private</code> <code>bool</code> <p>whether to include items that begin with '_' (True) or to exclude them (False). Defauls to True.</p> <code>True</code>"},{"location":"reference/miller/examiners/#miller.examiners.InstanceInspector.annotations","title":"<code>annotations: dict[str, Type[Any]]</code>  <code>property</code>","text":"<p>dict of parameters and annotated type hints in 'item'.</p> <p>Returns:</p> Type Description <code>dict[str, Type[Any]]</code> <p>dict[str, Type[Any]]: keys are parameter/attribute names and values are type hints.</p>"},{"location":"reference/miller/examiners/#miller.examiners.InstanceInspector.include_private","title":"<code>include_private: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Properties</p>"},{"location":"reference/miller/examiners/#miller.examiners.InstanceInspector.methods","title":"<code>methods: dict[str, types.MethodType]</code>  <code>property</code>","text":"<p>dict of method names and methods in 'item'.</p> <p>Returns:</p> Type Description <code>dict[str, MethodType]</code> <p>dict[str, types.MethodType]: keys are method names and values are  methods.</p>"},{"location":"reference/miller/examiners/#miller.examiners.InstanceInspector.parameters","title":"<code>parameters: list[str]</code>  <code>property</code>","text":"<p>Names of parameters from a dataclass in 'item'.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: names of parameters for a dataclass.</p>"},{"location":"reference/miller/examiners/#miller.examiners.InstanceInspector.properties","title":"<code>properties: dict[str, Any]</code>  <code>property</code>","text":"<p>dict of property names and property values in 'item'.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: keys are property names and values are property  values.</p>"},{"location":"reference/miller/examiners/#miller.examiners.InstanceInspector.signatures","title":"<code>signatures: dict[str, inspect.Signature]</code>  <code>property</code>","text":"<p>dict of method names and signatures in 'item'.</p> <p>Returns:</p> Type Description <code>dict[str, Signature]</code> <p>dict[str, inspect.Signature]: keys are method names and values are  signatures for those methods.</p>"},{"location":"reference/miller/examiners/#miller.examiners.ModuleInspector","title":"<code>ModuleInspector</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Inspector</code></p> <p>Inspector for accessing module information from 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>ModuleType</code> <p>module to inspect.</p> required <code>include_private</code> <code>bool</code> <p>whether to include items that begin with '_' (True) or to exclude them (True). Defauls to False.</p> <code>True</code>"},{"location":"reference/miller/examiners/#miller.examiners.ModuleInspector.classes","title":"<code>classes: dict[str, Type[Any]]</code>  <code>property</code>","text":"<p>dict of class names and classes in 'item'.</p> <p>Returns:</p> Type Description <code>dict[str, Type[Any]]</code> <p>dict[str, Type[Any]: keys are class names and values are classes.</p>"},{"location":"reference/miller/examiners/#miller.examiners.ModuleInspector.functions","title":"<code>functions: dict[str, types.FunctionType]</code>  <code>property</code>","text":"<p>dict of function names and functions in 'item'.</p> <p>Returns:</p> Type Description <code>dict[str, FunctionType]</code> <p>dict[str, types.FunctionType]: keys are function names and values  are functions.</p>"},{"location":"reference/miller/examiners/#miller.examiners.ModuleInspector.include_private","title":"<code>include_private: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Properties</p>"},{"location":"reference/miller/examiners/#miller.examiners.ModuleInspector.signatures","title":"<code>signatures: dict[str, inspect.Signature]</code>  <code>property</code>","text":"<p>dict of method names and method signatures in 'item'.</p> <p>Returns:</p> Type Description <code>dict[str, Signature]</code> <p>dict[str, inspect.Signature]: keys are method names and values are  signatures for those methods.</p>"},{"location":"reference/miller/examiners/#miller.examiners.PackageInspector","title":"<code>PackageInspector</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Inspector</code></p> <p>Inspector for accessing package information from 'item'.</p> <p>Attributes:</p> Name Type Description <code>item</code> <code>Union[Path, str]</code> <p>folder for which information should be made available.</p> <code>include_private</code> <code>bool</code> <p>whether to include items that begin with '_' (True) or to exclude them (False). Defauls to True.</p> <code>include_subfolders</code> <code>bool</code> <p>whether to include subitems in the package. Defaults to True.</p>"},{"location":"reference/miller/examiners/#miller.examiners.PackageInspector.files","title":"<code>files: list[pathlib.Path]</code>  <code>property</code>","text":"<p>Non-python-module file paths in 'item'.</p> <p>Returns:</p> Type Description <code>list[pathlib.Path]</code> <p>list[pathlib.Path]: list of non-python-module file paths.</p>"},{"location":"reference/miller/examiners/#miller.examiners.PackageInspector.folders","title":"<code>folders: list[pathlib.Path]</code>  <code>property</code>","text":"<p>Folder paths in 'item'.</p> <p>Returns:</p> Type Description <code>list[pathlib.Path]</code> <p>list[pathlib.Path]: list of folder paths.</p>"},{"location":"reference/miller/examiners/#miller.examiners.PackageInspector.include_subfolders","title":"<code>include_subfolders: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Initialization Methods</p>"},{"location":"reference/miller/examiners/#miller.examiners.PackageInspector.module_paths","title":"<code>module_paths: list[pathlib.Path]</code>  <code>property</code>","text":"<p>Python module file paths in 'item'.</p> <p>Returns:</p> Type Description <code>list[pathlib.Path]</code> <p>list[pathlib.Path]: list of python-module file paths.</p>"},{"location":"reference/miller/examiners/#miller.examiners.PackageInspector.modules","title":"<code>modules: dict[str, types.ModuleType]</code>  <code>property</code>","text":"<p>dict of python module names and modules in 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Union[str, Path]</code> <p>path of folder to examine.</p> required <p>Returns:</p> Type Description <code>dict[str, ModuleType]</code> <p>dict[str, types.ModuleType]: dict with str key names of python  modules and values as the corresponding modules.</p>"},{"location":"reference/miller/examiners/#miller.examiners.PackageInspector.paths","title":"<code>paths: list[pathlib.Path]</code>  <code>property</code>","text":"<p>All paths in 'item'.</p> <p>Returns:</p> Type Description <code>list[pathlib.Path]</code> <p>list[pathlib.Path]: list of all paths.</p>"},{"location":"reference/miller/framework/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> framework","text":"<p>framework: functions for changing global settings for miller Corey Rayburn Yung coreyrayburnyung@gmail.com Copyright 2020-2022, Corey Rayburn Yung License: Apache-2.0</p> <pre><code>Licensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre> <p>Contents:  </p> <p>ToDo:</p>"},{"location":"reference/miller/framework/#miller.framework.set_keyer","title":"<code>set_keyer(namer)</code>","text":"<p>Sets the global default function used to name items.</p> <p>Parameters:</p> Name Type Description Default <code>namer</code> <code>Callable[[object | Type[Any]], str]</code> <p>function that returns a  str name of any item passed.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if 'namer' is not callable.</p> Source code in <code>src/miller/framework.py</code> <pre><code>def set_keyer(namer: Callable[[object | Type[Any]], str]) -&gt; None:\n\"\"\"Sets the global default function used to name items.\n\n    Args:\n        namer (Callable[[object | Type[Any]], str]): function that returns a \n            str name of any item passed.\n\n    Raises:\n        TypeError: if 'namer' is not callable.\n\n    \"\"\"\n    if isinstance(namer, Callable):\n        configuration.KEYER = namer\n    else:\n        raise TypeError('extensions argument must be a sequence of strings')\n</code></pre>"},{"location":"reference/miller/framework/#miller.framework.set_module_extensions","title":"<code>set_module_extensions(extensions)</code>","text":"<p>Sets the global default rule of python module suffixes.</p> <p>Parameters:</p> Name Type Description Default <code>extensions</code> <code>Sequence[str]</code> <p>file extensions of python modules.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if 'extensions' is not a sequence of str type.</p> Source code in <code>src/miller/framework.py</code> <pre><code>def set_module_extensions(extensions: Sequence[str]) -&gt; None:\n\"\"\"Sets the global default rule of python module suffixes.\n\n    Args:\n        extensions (Sequence[str]): file extensions of python modules.\n\n    Raises:\n        TypeError: if 'extensions' is not a sequence of str type.\n\n    \"\"\"\n    if (isinstance(extensions, Sequence) \n            and not isinstance(extensions, str)\n            and all(isinstance(i, str) for i in extensions)):\n        configuration.MODULE_EXTENSIONS = extensions\n    else:\n        raise TypeError('extensions argument must be a sequence of strings')\n</code></pre>"},{"location":"reference/miller/framework/#miller.framework.set_recursion","title":"<code>set_recursion(recursive)</code>","text":"<p>Sets the global default rule whether tools should be recursive.</p> <p>If a 'recursive' argument is passed to a function that takes one, that argument will always take precedence. However, the default value is used  when an argument is not passed.</p> <p>Parameters:</p> Name Type Description Default <code>recursive</code> <code>bool</code> <p>value to set the RECURSIVE variable to.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if 'recursive' is not a boolean type.</p> Source code in <code>src/miller/framework.py</code> <pre><code>def set_recursion(recursive: bool) -&gt; None:\n\"\"\"Sets the global default rule whether tools should be recursive.\n\n    If a 'recursive' argument is passed to a function that takes one, that\n    argument will always take precedence. However, the default value is used \n    when an argument is not passed.\n\n    Args:\n        recursive (bool): value to set the RECURSIVE variable to.\n\n    Raises:\n        TypeError: if 'recursive' is not a boolean type.\n\n    \"\"\"\n    if isinstance(recursive, bool):\n        configuration.RECURSIVE = recursive\n    else:\n        raise TypeError('recursive argument must be a boolean type')\n</code></pre>"},{"location":"reference/miller/identity/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> identity","text":"<p>identity: introspection tools that return a bool whether an item is a type Corey Rayburn Yung coreyrayburnyung@gmail.com Copyright 2020-2022, Corey Rayburn Yung License: Apache-2.0</p> <pre><code>Licensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre> Contents <p>is_class: is_class_attribute: is_container: is_dict: is_file: is_folder: is_function: is_iterable: is_list: is_method: is_module: is_nested (dispatcher):     is_nested_dict:     is_nested_list:     is_nested_set:     is_nested_tuple: is_object: is_path: is_property: is_sequence: is_set: is_variable:</p> <p>ToDo:</p>"},{"location":"reference/miller/identity/#miller.identity.is_class","title":"<code>is_class(item, raise_error=None)</code>","text":"<p>Returns if 'item' is a class (and not an instance).</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>object to examine.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>if 'item' is a class (and not an instance).</p> Source code in <code>src/miller/identity.py</code> <pre><code>def is_class(item: Any, raise_error: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns if 'item' is a class (and not an instance).\n\n    Args:\n        item (Any): object to examine.\n\n    Returns:\n        bool: if 'item' is a class (and not an instance).\n\n    \"\"\"\n    return base.is_kind(\n        item = item,\n        checker = inspect.isclass,\n        raise_error = raise_error,\n        kind = 'class')\n</code></pre>"},{"location":"reference/miller/identity/#miller.identity.is_container","title":"<code>is_container(item, include_str=False, raise_error=None)</code>","text":"<p>Returns if 'item' is a container.</p> <p>If 'exclude_str' is True (the default) and 'item' is a str, False will be returned.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>object to examine.</p> required <code>include_str</code> <code>bool</code> <p>whether to return True if 'item' is a str.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>if 'item' is a container.</p> Source code in <code>src/miller/identity.py</code> <pre><code>def is_container(\n    item: Any, \n    include_str: bool = False, \n    raise_error: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns if 'item' is a container.\n\n    If 'exclude_str' is True (the default) and 'item' is a str, False will be\n    returned.\n\n    Args:\n        item (Any): object to examine.\n        include_str (bool): whether to return True if 'item' is a str.\n\n    Returns:\n        bool: if 'item' is a container.\n\n    \"\"\"\n    item = item.__class__ if inspect.isclass(item) else item\n    if not isinstance(item, Container):\n        return False\n    if include_str and isinstance(item, str):\n        return True\n    return base.is_kind(\n        item = item,\n        checker = inspect.isclass,\n        raise_error = raise_error,\n        kind = 'container')  \n    if not inspect.isclass(item):\n        item = item.__class__\n    return (\n        issubclass(item, Container)\n        and (not issubclass(item, str) or include_str))\n</code></pre>"},{"location":"reference/miller/identity/#miller.identity.is_dict","title":"<code>is_dict(item, raise_error=None)</code>","text":"<p>Returns if 'item' is a mutable mapping (generic dict type).</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>object to examine.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>if 'item' is a mutable mapping.</p> Source code in <code>src/miller/identity.py</code> <pre><code>def is_dict(item: Any, raise_error: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns if 'item' is a mutable mapping (generic dict type).\n\n    Args:\n        item (Any): object to examine.\n\n    Returns:\n        bool: if 'item' is a mutable mapping.\n\n    \"\"\"  \n    if not inspect.isclass(item):\n        item = item.__class__\n    return isinstance(item, MutableMapping) \n</code></pre>"},{"location":"reference/miller/identity/#miller.identity.is_file","title":"<code>is_file(item, raise_error=None)</code>","text":"<p>Returns whether 'item' is a file.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str | Path</code> <p>path to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether 'item' is a file.</p> Source code in <code>src/miller/identity.py</code> <pre><code>def is_file(\n    item: str | pathlib.Path, \n    raise_error: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns whether 'item' is a file.\n\n    Args:\n        item (str | pathlib.Path): path to check.\n\n    Returns:\n        bool: whether 'item' is a file.\n\n    \"\"\" \n    item = camina.pathlibify(item)\n    return item.exists() and item.is_file()\n</code></pre>"},{"location":"reference/miller/identity/#miller.identity.is_folder","title":"<code>is_folder(item, raise_error=None)</code>","text":"<p>Returns whether 'item' is a path to a folder.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str | Path</code> <p>path to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether 'item' is a path to a folder.</p> Source code in <code>src/miller/identity.py</code> <pre><code>def is_folder(\n    item: str | pathlib.Path, \n    raise_error: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns whether 'item' is a path to a folder.\n\n    Args:\n        item (str | pathlib.Path): path to check.\n\n    Returns:\n        bool: whether 'item' is a path to a folder.\n\n    \"\"\" \n    item = camina.pathlibify(item)\n    return item.exists() and item.is_dir()\n</code></pre>"},{"location":"reference/miller/identity/#miller.identity.is_function","title":"<code>is_function(item, raise_error=None)</code>","text":"<p>Returns if 'item' is a function.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>object to examine.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>if 'item' is a function.</p> Source code in <code>src/miller/identity.py</code> <pre><code>def is_function(item: Any, raise_error: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns if 'item' is a function.\n\n    Args:\n        item (Any): object to examine.\n\n    Returns:\n        bool: if 'item' is a function.\n\n    \"\"\"  \n    return isinstance(item, types.FunctionType)\n</code></pre>"},{"location":"reference/miller/identity/#miller.identity.is_instance","title":"<code>is_instance(item, raise_error=None)</code>","text":"<p>Returns if 'item' is an instance (and not a class).</p> <p>To rule out edge cases, this function checks that 'item' is not a class and has the attribute 'class'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>object to examine.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>if 'item' is an instance (and not a class).</p> Source code in <code>src/miller/identity.py</code> <pre><code>def is_instance(item: Any, raise_error: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns if 'item' is an instance (and not a class).\n\n    To rule out edge cases, this function checks that 'item' is not a class and\n    has the attribute '__class__'.\n\n    Args:\n        item (Any): object to examine.\n\n    Returns:\n        bool: if 'item' is an instance (and not a class).\n\n    \"\"\"  \n    return hasattr(item, '__class__') and not is_class(item)\n</code></pre>"},{"location":"reference/miller/identity/#miller.identity.is_iterable","title":"<code>is_iterable(item, include_str=False, raise_error=None)</code>","text":"<p>Returns if 'item' is iterable.</p> <p>If 'exclude_str' is True (the default) and 'item' is a str, False will be returned.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>object to examine.</p> required <code>include_str</code> <code>bool</code> <p>whether to return True if 'item' is a str.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>if 'item' is iterable.</p> Source code in <code>src/miller/identity.py</code> <pre><code>def is_iterable(\n    item: Any, \n    include_str: bool = False, \n    raise_error: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns if 'item' is iterable.\n\n    If 'exclude_str' is True (the default) and 'item' is a str, False will be\n    returned.\n\n    Args:\n        item (Any): object to examine.\n        include_str (bool): whether to return True if 'item' is a str.\n\n    Returns:\n        bool: if 'item' is iterable.\n\n    \"\"\" \n    if not inspect.isclass(item):\n        item = item.__class__\n    return (\n        issubclass(item, Iterable) \n        and (not issubclass(item, str) or include_str))\n</code></pre>"},{"location":"reference/miller/identity/#miller.identity.is_list","title":"<code>is_list(item, raise_error=None)</code>","text":"<p>Returns if 'item' is a mutable sequence (generic list type).</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>object to examine.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>if 'item' is a mutable list.</p> Source code in <code>src/miller/identity.py</code> <pre><code>def is_list(item: Any, raise_error: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns if 'item' is a mutable sequence (generic list type).\n\n    Args:\n        item (Any): object to examine.\n\n    Returns:\n        bool: if 'item' is a mutable list.\n\n    \"\"\"\n    if not inspect.isclass(item):\n        item = item.__class__\n    return isinstance(item, MutableSequence)\n</code></pre>"},{"location":"reference/miller/identity/#miller.identity.is_module","title":"<code>is_module(item, raise_error=None)</code>","text":"<p>Returns whether 'item' is a python-module file.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str | Path</code> <p>path to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether 'item' is a python-module file.</p> Source code in <code>src/miller/identity.py</code> <pre><code>def is_module(\n    item: str | pathlib.Path, \n    raise_error: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns whether 'item' is a python-module file.\n\n    Args:\n        item (str | pathlib.Path): path to check.\n\n    Returns:\n        bool: whether 'item' is a python-module file.\n\n    \"\"\"  \n    item = camina.pathlibify(item)\n    return (\n        item.exists() \n        and item.is_file() \n        and item.suffix in configuration.MODULE_EXTENSIONS)\n</code></pre>"},{"location":"reference/miller/identity/#miller.identity.is_nested","title":"<code>is_nested(item, /, raise_error=None)</code>","text":"<p>Returns if 'item' is nested at least one-level.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>object</code> <p>instance to examine.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if 'item' does not match any of the registered types.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>if 'item' is a nested mapping.</p> Source code in <code>src/miller/identity.py</code> <pre><code>@functools.singledispatch\ndef is_nested(item: object, /, raise_error: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns if 'item' is nested at least one-level.\n\n    Args:\n        item (object): instance to examine.\n\n    Raises:\n        TypeError: if 'item' does not match any of the registered types.\n\n    Returns:\n        bool: if 'item' is a nested mapping.\n\n    \"\"\" \n    raise TypeError(f'item {item} is not supported by {__name__}')\n</code></pre>"},{"location":"reference/miller/identity/#miller.identity.is_nested_dict","title":"<code>is_nested_dict(item, /, raise_error=None)</code>","text":"<p>Returns if 'item' is nested at least one-level.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Mapping[Any, Any]</code> <p>object to examine.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>if 'item' is a nested mapping.</p> Source code in <code>src/miller/identity.py</code> <pre><code>@is_nested.register(Mapping)   \ndef is_nested_dict(\n    item: Mapping[Any, Any], /, \n    raise_error: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns if 'item' is nested at least one-level.\n\n    Args:\n        item (Mapping[Any, Any]): object to examine.\n\n    Returns:\n        bool: if 'item' is a nested mapping.\n\n    \"\"\" \n    return (\n        isinstance(item, Mapping) \n        and any(isinstance(v, Mapping) for v in item.values()))\n</code></pre>"},{"location":"reference/miller/identity/#miller.identity.is_nested_list","title":"<code>is_nested_list(item, /, raise_error=None)</code>","text":"<p>Returns if 'item' is nested at least one-level.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>MutableSequence[Any]</code> <p>object to examine.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>if 'item' is a nested sequence.</p> Source code in <code>src/miller/identity.py</code> <pre><code>@is_nested.register(MutableSequence)     \ndef is_nested_list(\n    item: MutableSequence[Any], /, \n    raise_error: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns if 'item' is nested at least one-level.\n\n    Args:\n        item (MutableSequence[Any]): object to examine.\n\n    Returns:\n        bool: if 'item' is a nested sequence.\n\n    \"\"\" \n    return is_sequence(item)and any(is_sequence(item = v) for v in item)\n</code></pre>"},{"location":"reference/miller/identity/#miller.identity.is_nested_set","title":"<code>is_nested_set(item, /, raise_error=None)</code>","text":"<p>Returns if 'item' is nested at least one-level.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>item</code> <p>Set[Any]): object to examine.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>if 'item' is a nested set.</p> Source code in <code>src/miller/identity.py</code> <pre><code>@is_nested.register(Set)         \ndef is_nested_set(\n    item: Set[Any], /, \n    raise_error: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns if 'item' is nested at least one-level.\n\n    Args:\n        item (item: Set[Any]): object to examine.\n\n    Returns:\n        bool: if 'item' is a nested set.\n\n    \"\"\" \n    return is_set(item) and any(is_set(item = v) for v in item)\n</code></pre>"},{"location":"reference/miller/identity/#miller.identity.is_nested_tuple","title":"<code>is_nested_tuple(item, /, raise_error=None)</code>","text":"<p>Returns if 'item' is nested at least one-level.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>tuple[Any, ...]</code> <p>object to examine.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>if 'item' is a nested sequence.</p> Source code in <code>src/miller/identity.py</code> <pre><code>@is_nested.register(tuple)     \ndef is_nested_tuple(\n    item: tuple[Any, ...], /, \n    raise_error: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns if 'item' is nested at least one-level.\n\n    Args:\n        item (tuple[Any, ...]): object to examine.\n\n    Returns:\n        bool: if 'item' is a nested sequence.\n\n    \"\"\" \n    return is_sequence(item) and any(is_sequence(item = v) for v in item)\n</code></pre>"},{"location":"reference/miller/identity/#miller.identity.is_object","title":"<code>is_object(item, raise_error=None)</code>","text":"<p>Returns if 'item' is an object (and not a class or function).</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>object to examine.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether 'item' is an object (and not a class or function).</p> Source code in <code>src/miller/identity.py</code> <pre><code>def is_object(item: Any, raise_error: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns if 'item' is an object (and not a class or function).\n\n    Args:\n        item (Any): object to examine.\n\n    Returns:\n        bool: whether 'item' is an object (and not a class or function).\n\n    \"\"\" \n    return not is_function(item) and not is_class(item)\n</code></pre>"},{"location":"reference/miller/identity/#miller.identity.is_path","title":"<code>is_path(item, raise_error=None)</code>","text":"<p>Returns whether 'item' is a currently existing path.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str | Path</code> <p>path to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether 'item' is a currently existing path.</p> Source code in <code>src/miller/identity.py</code> <pre><code>def is_path(\n    item: str | pathlib.Path, \n    raise_error: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns whether 'item' is a currently existing path.\n\n    Args:\n        item (str | pathlib.Path): path to check.\n\n    Returns:\n        bool: whether 'item' is a currently existing path.\n\n    \"\"\" \n    item = camina.pathlibify(item)\n    return item.exists()\n</code></pre>"},{"location":"reference/miller/identity/#miller.identity.is_sequence","title":"<code>is_sequence(item, include_str=False, raise_error=None)</code>","text":"<p>Returns if 'item' is a sequence.</p> <p>If 'exclude_str' is True (the default) and 'item' is a str, False will be returned.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>object to examine.</p> required <code>include_str</code> <code>bool</code> <p>whether to return True if 'item' is a str.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>if 'item' is a sequence.</p> Source code in <code>src/miller/identity.py</code> <pre><code>def is_sequence(\n    item: Any, \n    include_str: bool = False, \n    raise_error: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns if 'item' is a sequence.\n\n    If 'exclude_str' is True (the default) and 'item' is a str, False will be\n    returned.\n\n    Args:\n        item (Any): object to examine.\n        include_str (bool): whether to return True if 'item' is a str.\n\n    Returns:\n        bool: if 'item' is a sequence.\n\n    \"\"\" \n    if not inspect.isclass(item):\n        item = item.__class__\n    return (\n        issubclass(item, Sequence)\n        and (not issubclass(item, str) or include_str))\n</code></pre>"},{"location":"reference/miller/identity/#miller.identity.is_set","title":"<code>is_set(item, raise_error=None)</code>","text":"<p>Returns if 'item' is a Set (generic type set).</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>object to examine.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>if 'item' is a set.</p> Source code in <code>src/miller/identity.py</code> <pre><code>def is_set(item: Any, raise_error: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns if 'item' is a Set (generic type set).\n\n    Args:\n        item (Any): object to examine.\n\n    Returns:\n        bool: if 'item' is a set.\n\n    \"\"\" \n    if not inspect.isclass(item):\n        item = item.__class__\n    return issubclass(item, Set)\n</code></pre>"},{"location":"reference/miller/modules/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> modules","text":"<p>modules: introspection tools for Python modules Corey Rayburn Yung coreyrayburnyung@gmail.com Copyright 2020-2022, Corey Rayburn Yung License: Apache-2.0</p> <pre><code>Licensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre> Contents <p>has_classes: has_functions: has_objects: list_classes: list_functions: list_objects: map_classes: map_functions: map_objects: name_classes: name_functions: name_objects:  </p> <p>ToDo:</p>"},{"location":"reference/miller/modules/#miller.modules._check_trait","title":"<code>_check_trait(item, attributes, raise_error, match_all, checker)</code>","text":"<p>Returns whether 'attributes' exist in 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>object | Type[Any]</code> <p>class or instance to examine.</p> required <code>attributes</code> <code>MutableSequence[str]</code> <p>names of attributes to check.</p> required <code>raise_error</code> <code>Optional[bool]</code> <p>whether to raise an error if any  'attributes' are not an attribute of 'item' (True) or to simply  return False in such situations. Defaults to None, which means the  global 'miller.RAISE_ERRORS' setting will be used.</p> required <code>match_all</code> <code>Optional[bool]</code> <p>whether all items in 'attributes' must match (True) or any of the items must match (False). Defaults to None, which means the global 'miller.MATCH_ALL' will be used.</p> required <code>checker</code> <code>Callable</code> <p>function to call to determine if an attribute in 'attributes' qualifies as the desired type.</p> required <p>Raises:</p> Type Description <code>AttributeError</code> <p>if some 'attributes' are not an attribute of 'item' and  'raise_error' is True (or if it is None and the global setting is True).</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether all 'attributes' exist in 'item'.</p> Source code in <code>src/miller/modules.py</code> <pre><code>def _check_trait(\n    item: Any,\n    attributes: MutableSequence[Any],\n    raise_error: bool,\n    match_all: bool,\n    checker: Callable) -&gt; bool:\n\"\"\"Returns whether 'attributes' exist in 'item'.\n\n    Args:\n        item (object | Type[Any]): class or instance to examine.\n        attributes (MutableSequence[str]): names of attributes to check.\n        raise_error (Optional[bool]): whether to raise an error if any \n            'attributes' are not an attribute of 'item' (True) or to simply \n            return False in such situations. Defaults to None, which means the \n            global 'miller.RAISE_ERRORS' setting will be used.\n        match_all (Optional[bool]): whether all items in 'attributes' must match\n            (True) or any of the items must match (False). Defaults to None,\n            which means the global 'miller.MATCH_ALL' will be used.\n        checker (Callable): function to call to determine if an attribute in\n            'attributes' qualifies as the desired type.\n\n    Raises:\n        AttributeError: if some 'attributes' are not an attribute of 'item' and \n            'raise_error' is True (or if it is None and the global setting is\n            True).\n\n    Returns:\n        bool: whether all 'attributes' exist in 'item'.\n\n    \"\"\"\n    match_all = configuration.MATCH_ALL if None else match_all \n    scope = all if match_all else any\n    kwargs = dict(raise_error = False)\n    check = scope(checker(item, a, **kwargs) for a in attributes)  \n    if not check and raise_error:\n        raise AttributeError(\n            f'Some of {attributes} are not attributes of {item}')\n    elif not check:\n        return False\n    else:\n        return True\n</code></pre>"},{"location":"reference/miller/modules/#miller.modules._get_object_mapping","title":"<code>_get_object_mapping(item, predicate=None, include_private=False)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>ModuleType | str</code> <p>description</p> required <code>predicate</code> <code>Callable</code> <p>description</p> <code>None</code> <code>include_private</code> <code>bool</code> <p>description. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Type[Any]]</code> <p>dict[str, Type[Any]]: description</p> Source code in <code>src/miller/modules.py</code> <pre><code>def _get_object_mapping(\n    item: types.ModuleType | str, \n    predicate: Optional[Callable] = None,\n    include_private: bool = False) -&gt; dict[str, Type[Any]]:\n\"\"\"_summary_\n\n    Args:\n        item (types.ModuleType | str): _description_\n        predicate (Callable): _description_\n        include_private (bool, optional): _description_. Defaults to False.\n\n    Returns:\n        dict[str, Type[Any]]: _description_\n\n    \"\"\"\n    if isinstance(item, str):\n        item = sys.modules[item]\n    if predicate is None:\n        objects = {\n            m[0]: m[1] for m in inspect.getmembers(item)\n            if m[1].__module__ == item.__name__}\n    else:\n        objects = {\n            m[0]: m[1] for m in inspect.getmembers(item, predicate)\n            if m[1].__module__ == item.__name__}        \n    if not include_private:\n        objects = camina.drop_privates(objects)\n    return objects\n</code></pre>"},{"location":"reference/miller/modules/#miller.modules.has_classes","title":"<code>has_classes(item, classes, raise_error=None, match_all=None)</code>","text":"<p>Returns whether 'classes' exist in 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>ModuleType | str</code> <p>module or its name to inspect.</p> required <code>classes</code> <code>MutableSequence[str]</code> <p>names of classes to check.</p> required <code>raise_error</code> <code>Optional[bool]</code> <p>whether to raise an error if any  'classes' are not an attribute of 'item' (True) or to simply  return False in such situations. Defaults to None, which means the  global 'miller.RAISE_ERRORS' setting will be used.</p> <code>None</code> <code>match_all</code> <code>Optional[bool]</code> <p>whether all items in 'classes' must match (True) or any of the items must match (False). Defaults to None, which means the global 'miller.MATCH_ALL' will be used.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether some or all (depending on 'match_all') of 'classes' exist  in 'item'.</p> Source code in <code>src/miller/modules.py</code> <pre><code>def has_classes(\n    item: types.ModuleType | str, \n    classes: MutableSequence[str], \n    raise_error: Optional[bool] = None,\n    match_all: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns whether 'classes' exist in 'item'.\n\n    Args:\n        item (types.ModuleType | str): module or its name to inspect.\n        classes (MutableSequence[str]): names of classes to check.\n        raise_error (Optional[bool]): whether to raise an error if any \n            'classes' are not an attribute of 'item' (True) or to simply \n            return False in such situations. Defaults to None, which means the \n            global 'miller.RAISE_ERRORS' setting will be used.\n        match_all (Optional[bool]): whether all items in 'classes' must match\n            (True) or any of the items must match (False). Defaults to None,\n            which means the global 'miller.MATCH_ALL' will be used.\n\n    Returns:\n        bool: whether some or all (depending on 'match_all') of 'classes' exist \n            in 'item'.\n\n    \"\"\"\n    item = sys.modules[item] if isinstance(item, str) else item\n    return base.has_elements(\n        checker = identity.is_class,\n        raise_error = raise_error,\n        match_all = match_all,\n        item = item,\n        attributes = classes)\n</code></pre>"},{"location":"reference/miller/modules/#miller.modules.has_functions","title":"<code>has_functions(item, functions, raise_error=None, match_all=None)</code>","text":"<p>Returns whether 'functions' exist in 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>ModuleType | str</code> <p>module or its name to inspect.</p> required <code>functions</code> <code>MutableSequence[str]</code> <p>names of functions to check.</p> required <code>raise_error</code> <code>Optional[bool]</code> <p>whether to raise an error if any  'functions' are not an attribute of 'item' (True) or to simply  return False in such situations. Defaults to None, which means the  global 'miller.RAISE_ERRORS' setting will be used.</p> <code>None</code> <code>match_all</code> <code>Optional[bool]</code> <p>whether all items in 'functions' must match (True) or any of the items must match (False). Defaults to None, which means the global 'miller.MATCH_ALL' will be used.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether some or all (depending on 'match_all') of 'functions'  exist in 'item'.</p> Source code in <code>src/miller/modules.py</code> <pre><code>def has_functions(\n    item: types.ModuleType | str, \n    functions: MutableSequence[str], \n    raise_error: Optional[bool] = None,\n    match_all: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns whether 'functions' exist in 'item'.\n\n    Args:\n        item (types.ModuleType | str): module or its name to inspect.\n        functions (MutableSequence[str]): names of functions to check.\n        raise_error (Optional[bool]): whether to raise an error if any \n            'functions' are not an attribute of 'item' (True) or to simply \n            return False in such situations. Defaults to None, which means the \n            global 'miller.RAISE_ERRORS' setting will be used.\n        match_all (Optional[bool]): whether all items in 'functions' must match\n            (True) or any of the items must match (False). Defaults to None,\n            which means the global 'miller.MATCH_ALL' will be used.\n\n    Returns:\n        bool: whether some or all (depending on 'match_all') of 'functions' \n            exist in 'item'.\n\n    \"\"\"\n    item = sys.modules[item] if isinstance(item, str) else item\n    return base.has_elements(\n        checker = identity.is_function,\n        raise_error = raise_error,\n        match_all = match_all,\n        item = item,\n        attributes = functions)\n</code></pre>"},{"location":"reference/miller/modules/#miller.modules.has_objects","title":"<code>has_objects(item, objects, raise_error=None, match_all=None)</code>","text":"<p>Returns whether 'objects' exist in 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>ModuleType | str</code> <p>module or its name to inspect.</p> required <code>objects</code> <code>MutableSequence[str]</code> <p>names of objects to check.</p> required <code>raise_error</code> <code>Optional[bool]</code> <p>whether to raise an error if any  'objects' are not an attribute of 'item' (True) or to simply  return False in such situations. Defaults to None, which means the  global 'miller.RAISE_ERRORS' setting will be used.</p> <code>None</code> <code>match_all</code> <code>Optional[bool]</code> <p>whether all items in 'objects' must match (True) or any of the items must match (False). Defaults to None, which means the global 'miller.MATCH_ALL' will be used.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether some or all (depending on 'match_all') of 'objects' exist  in 'item'.</p> Source code in <code>src/miller/modules.py</code> <pre><code>def has_objects(\n    item: types.ModuleType | str, \n    objects: MutableSequence[str], \n    raise_error: Optional[bool] = None,\n    match_all: Optional[bool] = None) -&gt; bool:\n\"\"\"Returns whether 'objects' exist in 'item'.\n\n    Args:\n        item (types.ModuleType | str): module or its name to inspect.\n        objects (MutableSequence[str]): names of objects to check.\n        raise_error (Optional[bool]): whether to raise an error if any \n            'objects' are not an attribute of 'item' (True) or to simply \n            return False in such situations. Defaults to None, which means the \n            global 'miller.RAISE_ERRORS' setting will be used.\n        match_all (Optional[bool]): whether all items in 'objects' must match\n            (True) or any of the items must match (False). Defaults to None,\n            which means the global 'miller.MATCH_ALL' will be used.\n\n    Returns:\n        bool: whether some or all (depending on 'match_all') of 'objects' exist \n            in 'item'.\n\n    \"\"\"\n    item = sys.modules[item] if isinstance(item, str) else item\n    return base.has_elements(\n        checker = identity.is_object,\n        raise_error = raise_error,\n        match_all = match_all,\n        item = item,\n        attributes = objects)\n</code></pre>"},{"location":"reference/miller/modules/#miller.modules.list_classes","title":"<code>list_classes(item, raise_error=None, include_private=False)</code>","text":"<p>Returns list of classes in 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>ModuleType | str</code> <p>module or its name to inspect.</p> required <code>include_private</code> <code>bool</code> <p>whether to include items that begin with '_' (True) or to exclude them (False). Defauls to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[Type[Any]]</code> <p>list[Type[Any]]: list of classes in 'item'.</p> Source code in <code>src/miller/modules.py</code> <pre><code>def list_classes(\n    item: types.ModuleType | str, \n    raise_error: Optional[bool] = None,\n    include_private: bool = False) -&gt; list[Type[Any]]:\n\"\"\"Returns list of classes in 'item'.\n\n    Args:\n        item (types.ModuleType | str): module or its name to inspect.\n        include_private (bool): whether to include items that begin with '_'\n            (True) or to exclude them (False). Defauls to False.\n\n    Returns:\n        list[Type[Any]]: list of classes in 'item'.\n\n    \"\"\"\n    kwargs = dict(item = item, include_private = include_private)\n    return list(map_classes(**kwargs).values())\n</code></pre>"},{"location":"reference/miller/modules/#miller.modules.list_functions","title":"<code>list_functions(item, include_private=False)</code>","text":"<p>Returns list of functions in 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>ModuleType | str</code> <p>module or its name to inspect.</p> required <code>include_private</code> <code>bool</code> <p>whether to include items that begin with '_' (True) or to exclude them (False). Defauls to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[types.FunctionType]</code> <p>list[types.FunctionType]: list of functions in 'item'.</p> Source code in <code>src/miller/modules.py</code> <pre><code>def list_functions(\n    item: types.ModuleType | str, \n    include_private: bool = False) -&gt; list[types.FunctionType]:\n\"\"\"Returns list of functions in 'item'.\n\n    Args:\n        item (types.ModuleType | str): module or its name to inspect.\n        include_private (bool): whether to include items that begin with '_'\n            (True) or to exclude them (False). Defauls to False.\n\n    Returns:\n        list[types.FunctionType]: list of functions in 'item'.\n\n    \"\"\"\n    kwargs = dict(item = item, include_private = include_private)\n    return list(map_functions(**kwargs).values())\n</code></pre>"},{"location":"reference/miller/modules/#miller.modules.list_objects","title":"<code>list_objects(item, include_private=False)</code>","text":"<p>Returns list of objects in 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>ModuleType | str</code> <p>module or its name to inspect.</p> required <code>include_private</code> <code>bool</code> <p>whether to include items that begin with '_' (True) or to exclude them (False). Defauls to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>list[Any]</code> <p>list of objects in 'item'.</p> Source code in <code>src/miller/modules.py</code> <pre><code>def list_objects(\n    item: types.ModuleType | str, \n    include_private: bool = False) -&gt; list[Any]:\n\"\"\"Returns list of objects in 'item'.\n\n    Args:\n        item (types.ModuleType | str): module or its name to inspect.\n        include_private (bool): whether to include items that begin with '_'\n            (True) or to exclude them (False). Defauls to False.\n\n    Returns:\n        Any: list of objects in 'item'.\n\n    \"\"\"\n    kwargs = dict(item = item, include_private = include_private)\n    return list(map_objects(**kwargs).values())\n</code></pre>"},{"location":"reference/miller/modules/#miller.modules.map_classes","title":"<code>map_classes(item, include_private=False)</code>","text":"<p>Returns dict of classes in 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>ModuleType | str</code> <p>module or its name to inspect.</p> required <code>include_private</code> <code>bool</code> <p>whether to include items that begin with '_' (True) or to exclude them (False). Defauls to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Type[Any]]</code> <p>dict[str, Type[Any]]: dict with keys being class names and values being classes.</p> Source code in <code>src/miller/modules.py</code> <pre><code>def map_classes(\n    item: types.ModuleType | str, \n    include_private: bool = False) -&gt; dict[str, Type[Any]]:\n\"\"\"Returns dict of classes in 'item'.\n\n    Args:\n        item (types.ModuleType | str): module or its name to inspect.\n        include_private (bool): whether to include items that begin with '_'\n            (True) or to exclude them (False). Defauls to False.\n\n    Returns:\n        dict[str, Type[Any]]: dict with keys being class names and values\n            being classes. \n\n    \"\"\"\n    return _get_object_mapping(\n        item = item, \n        predicate = inspect.isclass, \n        include_private = include_private)\n</code></pre>"},{"location":"reference/miller/modules/#miller.modules.map_functions","title":"<code>map_functions(item, include_private=False)</code>","text":"<p>Returns dict of functions in 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>ModuleType | str</code> <p>module or its name to inspect.</p> required <code>include_private</code> <code>bool</code> <p>whether to include items that begin with '_' (True) or to exclude them (False). Defauls to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Type[Any]]</code> <p>dict[str, Type[Any]]: dict with keys being function names and values being functions.</p> Source code in <code>src/miller/modules.py</code> <pre><code>def map_functions(\n    item: types.ModuleType | str, \n    include_private: bool = False) -&gt; dict[str, Type[Any]]:\n\"\"\"Returns dict of functions in 'item'.\n\n    Args:\n        item (types.ModuleType | str): module or its name to inspect.\n        include_private (bool): whether to include items that begin with '_'\n            (True) or to exclude them (False). Defauls to False.\n\n    Returns:\n        dict[str, Type[Any]]: dict with keys being function names and values\n            being functions. \n\n    \"\"\"\n    return _get_object_mapping(\n        item = item, \n        predicate = inspect.isfunction, \n        include_private = include_private)\n</code></pre>"},{"location":"reference/miller/modules/#miller.modules.map_objects","title":"<code>map_objects(item, include_private=False)</code>","text":"<p>Returns dict of objects in 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>ModuleType | str</code> <p>module or its name to inspect.</p> required <code>include_private</code> <code>bool</code> <p>whether to include items that begin with '_' (True) or to exclude them (False). Defauls to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Type[Any]]</code> <p>dict[str, Type[Any]]: dict with keys being object names and values being objects.</p> Source code in <code>src/miller/modules.py</code> <pre><code>def map_objects(\n    item: types.ModuleType | str, \n    include_private: bool = False) -&gt; dict[str, Type[Any]]:\n\"\"\"Returns dict of objects in 'item'.\n\n    Args:\n        item (types.ModuleType | str): module or its name to inspect.\n        include_private (bool): whether to include items that begin with '_'\n            (True) or to exclude them (False). Defauls to False.\n\n    Returns:\n        dict[str, Type[Any]]: dict with keys being object names and values\n            being objects. \n\n    \"\"\"\n    return _get_object_mapping(\n        item = item, \n        predicate = None, \n        include_private = include_private)  \n</code></pre>"},{"location":"reference/miller/modules/#miller.modules.name_classes","title":"<code>name_classes(item, include_private=False)</code>","text":"<p>Returns list of string names of classes in 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>ModuleType | str</code> <p>module or its name to inspect.</p> required <code>include_private</code> <code>bool</code> <p>whether to include items that begin with '_' (True) or to exclude them (False). Defauls to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[Type[types.FunctionType]]: list of functions in 'item'.</p> Source code in <code>src/miller/modules.py</code> <pre><code>def name_classes(\n    item: types.ModuleType | str, \n    include_private: bool = False) -&gt; list[str]:\n\"\"\"Returns list of string names of classes in 'item'.\n\n    Args:\n        item (types.ModuleType | str): module or its name to inspect.\n        include_private (bool): whether to include items that begin with '_'\n            (True) or to exclude them (False). Defauls to False.\n\n    Returns:\n        list[Type[types.FunctionType]]: list of functions in 'item'.\n\n    \"\"\"\n    kwargs = dict(item = item, include_private = include_private)\n    return list(map_classes(**kwargs).keys())\n</code></pre>"},{"location":"reference/miller/modules/#miller.modules.name_functions","title":"<code>name_functions(item, include_private=False)</code>","text":"<p>Returns list of string names of functions in 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>ModuleType | str</code> <p>module or its name to inspect.</p> required <code>include_private</code> <code>bool</code> <p>whether to include items that begin with '_' (True) or to exclude them (False). Defauls to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[Type[types.FunctionType]]: list of functions in 'item'.</p> Source code in <code>src/miller/modules.py</code> <pre><code>def name_functions(\n    item: types.ModuleType | str, \n    include_private: bool = False) -&gt; list[str]:\n\"\"\"Returns list of string names of functions in 'item'.\n\n    Args:\n        item (types.ModuleType | str): module or its name to inspect.\n        include_private (bool): whether to include items that begin with '_'\n            (True) or to exclude them (False). Defauls to False.\n\n    Returns:\n        list[Type[types.FunctionType]]: list of functions in 'item'.\n\n    \"\"\"\n    kwargs = dict(item = item, include_private = include_private)\n    return list(map_functions(**kwargs).keys())\n</code></pre>"},{"location":"reference/miller/modules/#miller.modules.name_objects","title":"<code>name_objects(item, include_private=False)</code>","text":"<p>Returns list of names of objects in 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>ModuleType | str</code> <p>module or its name to inspect.</p> required <code>include_private</code> <code>bool</code> <p>whether to include items that begin with '_' (True) or to exclude them (False). Defauls to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>list[Any]</code> <p>list of names of objects in 'item'.</p> Source code in <code>src/miller/modules.py</code> <pre><code>def name_objects(\n    item: types.ModuleType | str, \n    include_private: bool = False) -&gt; list[Any]:\n\"\"\"Returns list of names of objects in 'item'.\n\n    Args:\n        item (types.ModuleType | str): module or its name to inspect.\n        include_private (bool): whether to include items that begin with '_'\n            (True) or to exclude them (False). Defauls to False.\n\n    Returns:\n        Any: list of names of objects in 'item'.\n\n    \"\"\"\n    kwargs = dict(item = item, include_private = include_private)\n    return list(map_objects(**kwargs).keys())\n</code></pre>"}]}